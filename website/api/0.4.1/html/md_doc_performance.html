<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: Performance Notes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdjson
   &#160;<span id="projectnumber">0.4.1</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Performance Notes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>simdjson strives to be at its fastest <em>without tuning</em>, and generally achieves this. However, there are still some scenarios where tuning can enhance performance.</p>
<ul>
<li><a href="#reusing-the-parser-for-maximum-efficiency">Reusing the parser for maximum efficiency</a><ul>
<li><a href="#keeping-documents-around-for-longer">Keeping documents around for longer</a></li>
</ul>
</li>
<li><a href="#server-loops-long-running-processes-and-memory-capacity">Server Loops: Long-Running Processes and Memory Capacity</a></li>
<li><a href="#large-files-and-huge-page-support">Large files and huge page support</a></li>
<li><a href="#computed-gotos">Computed GOTOs</a></li>
<li><a href="#number-parsing">Number parsing</a></li>
<li><a href="#visual-studio">Visual Studio</a></li>
<li><a href="#downclocking">Downclocking</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md49"></a>
Reusing the parser for maximum efficiency</h1>
<p>If you're using simdjson to parse multiple documents, or in a loop, you should make a parser once and reuse it. The simdjson library will allocate and retain internal buffers between parses, keeping buffers hot in cache and keeping memory allocation and initialization to a minimum. In this manner, you can parse terabytes of JSON data without doing any new allocation.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">dom::parser parser;</div>
<div class="line"> </div>
<div class="line">// This initializes buffers and a document big enough to handle this JSON.</div>
<div class="line">dom::element doc = parser.parse(&quot;[ true, false ]&quot;_padded);</div>
<div class="line">cout &lt;&lt; doc &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">// This reuses the existing buffers, and reuses and *overwrites* the old document</div>
<div class="line">doc = parser.parse(&quot;[1, 2, 3]&quot;_padded);</div>
<div class="line">cout &lt;&lt; doc &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">// This also reuses the existing buffers, and reuses and *overwrites* the old document</div>
<div class="line">dom::element doc2 = parser.parse(&quot;true&quot;_padded);</div>
<div class="line">// Even if you keep the old reference around, doc and doc2 refer to the same document.</div>
<div class="line">cout &lt;&lt; doc &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; doc2 &lt;&lt; endl;</div>
</div><!-- fragment --><p>It's not just internal buffers though. The simdjson library reuses the document itself. The dom::element, dom::object and dom::array instances are <em>references</em> to the internal document. You are only <em>borrowing</em> the document from simdjson, which purposely reuses and overwrites it each time you call parse. This prevent wasteful and unnecessary memory allocation in 99% of cases where JSON is just read, used, and converted to native values or thrown away.</p>
<blockquote class="doxtable">
<p><b>You are only borrowing the document from the simdjson parser. Don't keep it long term!</b> </p>
</blockquote>
<p>This is key: don't keep the <code>document&amp;</code>, <code>dom::element</code>, <code>dom::array</code>, <code>dom::object</code> or <code>string_view</code> objects you get back from the API. Convert them to C++ native values, structs and arrays that you own.</p>
<h1><a class="anchor" id="autotoc_md50"></a>
Server Loops: Long-Running Processes and Memory Capacity</h1>
<p>The simdjson library automatically expands its memory capacity when larger documents are parsed, so that you don't unexpectedly fail. In a short process that reads a bunch of files and then exits, this works pretty flawlessly.</p>
<p>Server loops, though, are long-running processes that will keep the parser around forever. This means that if you encounter a really, really large document, simdjson will not resize back down. The simdjson library lets you adjust your allocation strategy to prevent your server from growing without bound:</p>
<ul>
<li>You can set a <em>max capacity</em> when constructing a parser:</li>
</ul>
<div class="fragment"><div class="line">{c++}</div>
<div class="line"> dom::parser parser(1000*1000); // Never grow past documents &gt; 1MB</div>
<div class="line"> for (web_request request : listen()) {</div>
<div class="line">   dom::element doc;</div>
<div class="line">   auto error = parser.parse(request.body).get(doc);</div>
<div class="line">   // If the document was above our limit, emit 413 = payload too large</div>
<div class="line">   if (error == CAPACITY) { request.respond(413); continue; }</div>
<div class="line">   // ...</div>
<div class="line"> }</div>
</div><!-- fragment --><p>This parser will grow normally as it encounters larger documents, but will never pass 1MB.</p>
<ul>
<li>You can set a <em>fixed capacity</em> that never grows, as well, which can be excellent for predictability and reliability, since simdjson will never call malloc after startup!</li>
</ul>
<div class="fragment"><div class="line">{c++}</div>
<div class="line"> dom::parser parser(0); // This parser will refuse to automatically grow capacity</div>
<div class="line"> auto error = parser.allocate(1000*1000); // This allocates enough capacity to handle documents &lt;= 1MB</div>
<div class="line"> if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line"> for (web_request request : listen()) {</div>
<div class="line">   dom::element doc;</div>
<div class="line">   error = parser.parse(request.body).get(doc);</div>
<div class="line">   // If the document was above our limit, emit 413 = payload too large</div>
<div class="line">   if (error == CAPACITY) { request.respond(413); continue; }</div>
<div class="line">   // ...</div>
<div class="line"> }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md51"></a>
Large files and huge page support</h1>
<p>There is a memory allocation performance cost the first time you process a large file (e.g. 100MB). Between the cost of allocation, the fact that the memory is not in cache, and the initial zeroing of memory, <a href="https://lemire.me/blog/2020/01/14/how-fast-can-you-allocate-a-large-block-of-memory-in-c/">on some systems, allocation runs far slower than parsing (e.g., 1.4GB/s)</a>. Reusing the parser mitigates this by paying the cost once, but does not eliminate it.</p>
<p>In large file use cases, enabling transparent huge page allocation on the OS can help a lot. We haven't found the right way to do this on Windows or OS/X, but on Linux, you can enable transparent huge page allocation with a command like:</p>
<div class="fragment"><div class="line">echo always &gt; /sys/kernel/mm/transparent_hugepage/enabled</div>
</div><!-- fragment --><p>In general, when running benchmarks over large files, we recommend that you report performance numbers with and without huge pages if possible. Furthermore, you should amortize the parsing (e.g., by parsing several large files) to distinguish the time spent parsing from the time spent allocating memory. If you are using the <code>parse</code> benchmarking tool provided with the simdjson library, you can use the <code>-H</code> flag to omit the memory allocation cost from the benchmark results.</p>
<div class="fragment"><div class="line">./parse largefile # includes memory allocation cost</div>
<div class="line">./parse -H largefile # without memory allocation</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md52"></a>
Computed GOTOs</h1>
<p>For best performance, we use a technique called "computed goto" when the compiler supports it, it is also sometimes described as "Labels as Values". Though it is not part of the C++ standard, it is supported by many major compilers and it brings measurable performance benefits that are difficult to achieve otherwise. The computed gotos are automatically disabled under Visual Studio.</p>
<p>If you wish to forcefully disable computed gotos, you can do so by compiling the code with <code>-DSIMDJSON_NO_COMPUTED_GOTO=1</code>. It is not recommended to disable computed gotos if your compiler supports it. In fact, you should almost never need to be concerned with computed gotos.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Number parsing</h1>
<p>Some JSON files contain many floating-point values. It is the case with many GeoJSON files. Accurately parsing decimal strings into binary floating-point values with proper rounding is challenging. To our knowledge, it is not possible, in general, to parse streams of numbers at gigabytes per second using a single core. While using the simdjson library, it is possible that you might be limited to a few hundred megabytes per second if your JSON documents are densely packed with floating-point values.</p>
<ul>
<li>When possible, you should favor integer values written without a decimal point, as it simpler and faster to parse decimal integer values.</li>
<li>When serializing numbers, you should not use more digits than necessary: 17 digits is all that is needed to exactly represent double-precision floating-point numbers. Using many more digits than necessary will make your files larger and slower to parse.</li>
<li>When benchmarking parsing speeds, always report whether your JSON documents are made mostly of floating-point numbers when it is the case, since number parsing can then dominate the parsing time.</li>
</ul>
<h1><a class="anchor" id="autotoc_md54"></a>
Visual Studio</h1>
<p>On Intel and AMD Windows platforms, Microsoft Visual Studio enables programmers to build either 32-bit (x86) or 64-bit (x64) binaries. We urge you to always use 64-bit mode. Visual Studio 2019 should default on 64-bit builds when you have a 64-bit version of Windows, which we recommend.</p>
<p>We do not recommend that you compile simdjson with architecture-specific flags such as <code>arch:AVX2</code>. The simdjson library automatically selects the best execution kernel at runtime.</p>
<p>Recent versions of Microsoft Visual Studio on Windows provides support for the LLVM Clang compiler. You only need to install the "Clang compiler" optional component. You may also get a copy of the 64-bit LLVM CLang compiler for <a href="https://releases.llvm.org/download.html">Windows directly from LLVM</a>. The simdjson library fully supports the LLVM Clang compiler under Windows. In fact, you may get better performance out of simdjson with the LLVM Clang compiler than with the regular Visual Studio compiler.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Downclocking</h1>
<p>You should not expect the simdjson library to cause downclocking of your recent Intel CPU cores.</p>
<p>On some Intel processors, using SIMD instructions in a sustained manner on the same CPU core may result in a phenomenon called downclocking whereas the processor initially runs these instructions at a slow speed before reducing the frequency of the core for a short time (milliseconds). Intel refers to these states as licenses. On some current Intel processors, it occurs under two scenarios:</p>
<ul>
<li><a href="https://lemire.me/blog/2018/09/07/avx-512-when-and-how-to-use-these-new-instructions/">Whenever 512-bit AVX-512 instructions are used</a>.</li>
<li>Whenever heavy 256-bit or wider instructions are used. Heavy instructions are those involving floating point operations or integer multiplications (since these execute on the floating point unit).</li>
</ul>
<p>The simdjson library does not currently support AVX-512 instructions and it does not make use of heavy 256-bit instructions. Thus there should be no downclocking due to simdjson on recent processors. You may still be worried about which SIMD instruction set is used by simdjson. Thankfully, you can always determine and change which architecture-specific implementation is used. Thus even if your CPU supports AVX2, you do not need to use AVX2. You are in control. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
