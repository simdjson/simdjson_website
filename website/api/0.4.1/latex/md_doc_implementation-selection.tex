
\begin{DoxyItemize}
\item \href{\#overview}{\texttt{ Overview}}
\item \href{\#runtime-cpu-detection}{\texttt{ Runtime C\+PU Detection}}
\item \href{\#inspecting-the-detected-implementation}{\texttt{ Inspecting the Detected Implementation}}
\item \href{\#querying-available-implementations}{\texttt{ Querying Available Implementations}}
\item \href{\#manually-selecting-the-implementation}{\texttt{ Manually Selecting the Implementation}}
\end{DoxyItemize}\hypertarget{md_doc_implementation-selection_autotoc_md34}{}\doxysection{Overview}\label{md_doc_implementation-selection_autotoc_md34}
The simdjson library takes advantage of S\+I\+MD instruction sets such as N\+E\+ON, S\+SE and A\+VX to achieve much of its speed. Because these instruction sets work differently, simdjson has to compile a different version of the J\+S\+ON parser for different C\+PU architectures, often with different algorithms to take better advantage of a given C\+P\+U!

The current implementations are\+:
\begin{DoxyItemize}
\item haswell\+: A\+V\+X2 (2013 Intel Haswell or later)
\item westmere\+: S\+S\+E4.\+2 (2010 Westmere or later).
\item arm64\+: 64-\/bit A\+R\+Mv8-\/A N\+E\+ON
\item fallback\+: A generic implementation that runs on any 64-\/bit processor.
\end{DoxyItemize}

In many cases, you don\textquotesingle{}t know where your compiled binary is going to run, so simdjson automatically compiles {\itshape all} the implementations into the executable. On Intel, it will include 3 implementations (haswell, westmere and fallback), and on A\+RM it will include 2 (arm64 and fallback).

If you know more about where you\textquotesingle{}re going to run and want to save the space, you can disable any of these implementations at compile time with {\ttfamily -\/D\+S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+I\+M\+P\+L\+E\+M\+E\+N\+T\+A\+T\+I\+O\+N\+\_\+X=0} (where X is H\+A\+S\+W\+E\+LL, W\+E\+S\+T\+M\+E\+RE, A\+R\+M64 and F\+A\+L\+L\+B\+A\+CK).

The simdjson library automatically sets header flags for each implementation as it compiles; there is no need to set architecture-\/specific flags yourself (e.\+g., {\ttfamily -\/mavx2}, {\ttfamily /\+A\+V\+X2} or {\ttfamily -\/march=haswell}), and it may even break runtime dispatch and your binaries will fail to run on older processors.\hypertarget{md_doc_implementation-selection_autotoc_md35}{}\doxysection{Runtime C\+P\+U Detection}\label{md_doc_implementation-selection_autotoc_md35}
When you first use simdjson, it will detect the C\+PU you\textquotesingle{}re running on, and swap over to the fastest implementation for it. This is a small, one-\/time cost and for many people will be paid the first time they call {\ttfamily parse()} or {\ttfamily load()}.\hypertarget{md_doc_implementation-selection_autotoc_md36}{}\doxysection{Inspecting the Detected Implementation}\label{md_doc_implementation-selection_autotoc_md36}
You can check what implementation is running with {\ttfamily active\+\_\+implementation}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{cout << "simdjson v" << \#SIMDJSON\_VERSION << endl;}
\DoxyCodeLine{cout << "Detected the best implementation for your machine: " << simdjson::active\_implementation-\/>name();}
\DoxyCodeLine{cout << "(" << simdjson::active\_implementation-\/>description() << ")" << endl;}
\end{DoxyCode}


Implementation detection will happen in this case when you first call {\ttfamily name()}.\hypertarget{md_doc_implementation-selection_autotoc_md37}{}\doxysection{Querying Available Implementations}\label{md_doc_implementation-selection_autotoc_md37}
You can list all available implementations, regardless of which one was selected\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{for (auto implementation : simdjson::available\_implementations) \{}
\DoxyCodeLine{  cout << implementation-\/>name() << ": " << implementation-\/>description() << endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}


And look them up by name\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{cout << simdjson::available\_implementations["fallback"]-\/>description() << endl;}
\end{DoxyCode}
\hypertarget{md_doc_implementation-selection_autotoc_md38}{}\doxysection{Manually Selecting the Implementation}\label{md_doc_implementation-selection_autotoc_md38}
If you\textquotesingle{}re trying to do performance tests or see how different implementations of simdjson run, you can select the C\+PU architecture yourself\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{// Use the fallback implementation, even though my machine is fast enough for anything}
\DoxyCodeLine{simdjson::active\_implementation = simdjson::available\_implementations["fallback"];}
\end{DoxyCode}
 