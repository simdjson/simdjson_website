<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: The Basics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdjson
   &#160;<span id="projectnumber">0.7.0</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Basics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_basics_doxygen"></a></p>
<p>An overview of what you need to know to use simdjson, with examples.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Requirements</h1>
<ul>
<li>A recent compiler (LLVM clang6 or better, GNU GCC 7 or better) on a 64-bit (PPC, ARM or x64 Intel/AMD) POSIX systems such as macOS, freeBSD or Linux. We require that the compiler supports the C++11 standard or better.</li>
<li>Visual Studio 2017 or better under 64-bit Windows. Users should target a 64-bit build (x64) instead of a 32-bit build (x86). We support the LLVM clang compiler under Visual Studio (clangcl) as well as as the regular Visual Studio compiler.</li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
Including simdjson</h1>
<p>To include simdjson, copy the simdjson.h and simdjson.cpp files from the singleheader directory into your project. Then include the header file in your project with:</p>
<div class="fragment"><div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line">using namespace simdjson; // optional</div>
</div><!-- fragment --><p>You can compile with:</p>
<div class="fragment"><div class="line">c++ myproject.cpp simdjson.cpp</div>
</div><!-- fragment --><p>Note:</p><ul>
<li>Users on macOS and other platforms were default compilers do not provide C++11 compliant by default should request it with the appropriate flag (e.g., <code>c++ -std=c++17 myproject.cpp simdjson.cpp</code>).</li>
<li>Visual Studio users should compile with the <code>_CRT_SECURE_NO_WARNINGS</code> flag to avoid warnings with respect to our use of standard C functions such as <code>fopen</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Using simdjson with package managers</h1>
<p>You can install the simdjson library on your system or in your project using multiple package managers such as MSYS2, the conan package manager, vcpkg, brew, the apt package manager (debian-based Linux systems), the FreeBSD package manager (FreeBSD), and so on. <a href="https://github.com/simdjson/simdjson/wiki/Installing-simdjson-with-a-package-manager">Visit our wiki for more details</a>.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Using simdjson as a CMake dependency</h1>
<p>You can include the simdjson as a CMake dependency by including the following lines in your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  simdjson</div>
<div class="line">  GIT_REPOSITORY https://github.com/simdjson/simdjson.git</div>
<div class="line">  GIT_TAG  v0.6.1</div>
<div class="line">  GIT_SHALLOW TRUE)</div>
<div class="line"> </div>
<div class="line">set(SIMDJSON_JUST_LIBRARY ON CACHE INTERNAL &quot;&quot;)</div>
<div class="line">set(SIMDJSON_BUILD_STATIC ON CACHE INTERNAL &quot;&quot;)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(simdjson)</div>
</div><!-- fragment --><p>You should replace <code>GIT_TAG v0.6.1</code> by the version you need. If you omit <code>GIT_TAG v0.6.1</code>, you will work from the main branch of simdjson: we recommend that if you are working on production code,</p>
<p>Elsewhere in your project, you can declare dependencies on simdjson with lines such as these:</p>
<div class="fragment"><div class="line">add_executable(myprogram myprogram.cpp)</div>
<div class="line">target_link_libraries(myprogram simdjson)</div>
</div><!-- fragment --><p>We recommend CMake version 3.15 or better.</p>
<p>See <a href="https://github.com/simdjson/cmake_demo_single_file">our CMake demonstration</a>. It works under Linux, FreeBSD, macOS and Windows (including Visual Studio).</p>
<p>The CMake build in simdjson can be taylored with a few variables. You can see the available variables and their default values by entering the <code>cmake -LA</code> command.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
The Basics: Loading and Parsing JSON Documents</h1>
<p>The simdjson library offers a simple DOM tree API, which you can access by creating a <code>dom::parser</code> and calling the <code>load()</code> method:</p>
<div class="fragment"><div class="line">dom::parser parser;</div>
<div class="line">dom::element doc = parser.load(filename); // load and parse a file</div>
</div><!-- fragment --><p>Or by creating a padded string (for efficiency reasons, simdjson requires a string with SIMDJSON_PADDING bytes at the end) and calling <code>parse()</code>:</p>
<div class="fragment"><div class="line">dom::parser parser;</div>
<div class="line">dom::element doc = parser.parse(&quot;[1,2,3]&quot;_padded); // parse a string, the _padded suffix creates a simdjson::padded_string instance</div>
</div><!-- fragment --><p>The parsed document resulting from the <code>parser.load</code> and <code>parser.parse</code> calls depends on the <code>parser</code> instance. Thus the <code>parser</code> instance must remain in scope. Furthermore, you must have at most one parsed document in play per <code>parser</code> instance. You cannot copy a <code>parser</code> instance, you may only move it.</p>
<p>If you need to keep a document around long term, you can keep or move the parser instance. Note that moving a parser instance, or keeping one in a movable data structure like vector or map, can cause any outstanding <code>element</code>, <code>object</code> or <code>array</code> instances to be invalidated. If you need to store a parser in a movable data structure, you should use a <code>std::unique_ptr</code> to avoid this invalidation(e.g., <code>std::unique_ptr&lt;dom::parser&gt; parser(new dom::parser{})</code>).</p>
<p>During the<code>load</code> or <code>parse</code> calls, neither the input file nor the input string are ever modified. After calling <code>load</code> or <code>parse</code>, the source (either a file or a string) can be safely discarded. All of the JSON data is stored in the <code>parser</code> instance. The parsed document is also immutable in simdjson: you do not modify it by accessing it.</p>
<p>For best performance, a <code>parser</code> instance should be reused over several files: otherwise you will needlessly reallocate memory, an expensive process. It is also possible to avoid entirely memory allocations during parsing when using simdjson.</p>
<p>If you need a lower-level interface, you may call the function <code>parser.parse(const char * p, size_t l)</code> on a pointer <code>p</code> while specifying the length of your input <code>l</code> in bytes. To see how to get the very best performance from a low-level approach, you way want to read our <a href="https://github.com/simdjson/simdjson/blob/master/doc/performance.md#padding-and-temporary-copies">performance notes</a> on this topic (see the Padding and Temporary Copies section).</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Using the Parsed JSON</h1>
<p>Once you have an element, you can navigate it with idiomatic C++ iterators, operators and casts.</p>
<ul>
<li><b>Extracting Values (with exceptions):</b> You can cast a JSON element to a native type: <code>double(element)</code> or <code>double x = json_element</code>. This works for double, uint64_t, int64_t, bool, dom::object and dom::array. An exception is thrown if the cast is not possible.</li>
<li><b>Extracting Values (without exceptions):</b> You can use a variant usage of <code>get()</code> with error codes to avoid exceptions. You first declare the variable of the appropriate type (<code>double</code>, <code>uint64_t</code>, <code>int64_t</code>, <code>bool</code>, <code>dom::object</code> and <code>dom::array</code>) and pass it by reference to <code>get()</code> which gives you back an error code: e.g., <div class="fragment"><div class="line">simdjson::error_code error;</div>
<div class="line">simdjson::padded_string numberstring = &quot;1.2&quot;_padded; // our JSON input (&quot;1.2&quot;)</div>
<div class="line">simdjson::dom::parser parser;</div>
<div class="line">double value; // variable where we store the value to be parsed</div>
<div class="line">error = parser.parse(numberstring).get(value);</div>
<div class="line">if (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">std::cout &lt;&lt; &quot;I parsed &quot; &lt;&lt; value &lt;&lt; &quot; from &quot; &lt;&lt; numberstring.data() &lt;&lt; std::endl;</div>
</div><!-- fragment --></li>
<li><b>Field Access:</b> To get the value of the "foo" field in an object, use <code>object["foo"]</code>.</li>
<li><b>Array Iteration:</b> To iterate through an array, use <code>for (auto value : array) { ... }</code>. If you know the type of the value, you can cast it right there, too! <code>for (double value : array) { ... }</code></li>
<li><b>Object Iteration:</b> You can iterate through an object's fields, too: <code>for (auto [key, value] : object)</code></li>
<li><b>Array Index:</b> To get at an array value by index, use the at() method: <code>array.at(0)</code> gets the first element. <blockquote class="doxtable">
<p>Note that array[0] does not compile, because implementing [] gives the impression indexing is a O(1) operation, which it is not presently in simdjson. Instead, you should iterate over the elements using a for-loop, as in our examples. </p>
</blockquote>
</li>
<li><b>Array and Object size</b> Given an array or an object, you can get its size (number of elements or keys) with the <code>size()</code> method.</li>
<li><b>Checking an Element Type:</b> You can check an element's type with <code>element.type()</code>. It returns an <code>element_type</code> with values such as <code>simdjson::dom::element_type::ARRAY</code>, <code>simdjson::dom::element_type::OBJECT</code>, <code>simdjson::dom::element_type::INT64</code>, <code>simdjson::dom::element_type::UINT64</code>,<code>simdjson::dom::element_type::DOUBLE</code>, <code>simdjson::dom::element_type::BOOL</code> or, <code>simdjson::dom::element_type::NULL_VALUE</code>.</li>
<li><b>Output to Streams and Strings:</b> Given a document or an element (or node) out of a JSON document, you can output a minified string version using the C++ stream idiom (<code>out &lt;&lt; element</code>). You can also request the construction of a minified string version (<code>simdjson::minify(element)</code>).</li>
</ul>
<p>The following code illustrates all of the above:</p>
<div class="fragment"><div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line"> </div>
<div class="line">// Iterating through an array of objects</div>
<div class="line">for (dom::object car : parser.parse(cars_json)) {</div>
<div class="line">  // Accessing a field by name</div>
<div class="line">  cout &lt;&lt; &quot;Make/Model: &quot; &lt;&lt; car[&quot;make&quot;] &lt;&lt; &quot;/&quot; &lt;&lt; car[&quot;model&quot;] &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  // Casting a JSON element to an integer</div>
<div class="line">  uint64_t year = car[&quot;year&quot;];</div>
<div class="line">  cout &lt;&lt; &quot;- This car is &quot; &lt;&lt; 2020 - year &lt;&lt; &quot;years old.&quot; &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  // Iterating through an array of floats</div>
<div class="line">  double total_tire_pressure = 0;</div>
<div class="line">  for (double tire_pressure : car[&quot;tire_pressure&quot;]) {</div>
<div class="line">    total_tire_pressure += tire_pressure;</div>
<div class="line">  }</div>
<div class="line">  cout &lt;&lt; &quot;- Average tire pressure: &quot; &lt;&lt; (total_tire_pressure / 4) &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  // Writing out all the information about the car</div>
<div class="line">  for (auto field : car) {</div>
<div class="line">    cout &lt;&lt; &quot;- &quot; &lt;&lt; field.key &lt;&lt; &quot;: &quot; &lt;&lt; field.value &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is a different example illustrating the same ideas:</p>
<div class="fragment"><div class="line">auto abstract_json = R&quot;( [</div>
<div class="line">    {  &quot;12345&quot; : {&quot;a&quot;:12.34, &quot;b&quot;:56.78, &quot;c&quot;: 9998877}   },</div>
<div class="line">    {  &quot;12545&quot; : {&quot;a&quot;:11.44, &quot;b&quot;:12.78, &quot;c&quot;: 11111111}  }</div>
<div class="line">  ] )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line"> </div>
<div class="line">// Parse and iterate through an array of objects</div>
<div class="line">for (dom::object obj : parser.parse(abstract_json)) {</div>
<div class="line">    for(const auto&amp; key_value : obj) {</div>
<div class="line">      cout &lt;&lt; &quot;key: &quot; &lt;&lt; key_value.key &lt;&lt; &quot; : &quot;;</div>
<div class="line">      dom::object innerobj = key_value.value;</div>
<div class="line">      cout &lt;&lt; &quot;a: &quot; &lt;&lt; double(innerobj[&quot;a&quot;]) &lt;&lt; &quot;, &quot;;</div>
<div class="line">      cout &lt;&lt; &quot;b: &quot; &lt;&lt; double(innerobj[&quot;b&quot;]) &lt;&lt; &quot;, &quot;;</div>
<div class="line">      cout &lt;&lt; &quot;c: &quot; &lt;&lt; int64_t(innerobj[&quot;c&quot;]) &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And another one:</p>
<div class="fragment"><div class="line">auto abstract_json = R&quot;(</div>
<div class="line">  {  &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } } )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">double v = parser.parse(abstract_json)[&quot;str&quot;][&quot;123&quot;][&quot;abc&quot;];</div>
<div class="line">cout &lt;&lt; &quot;number: &quot; &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25"></a>
C++11 Support and string_view</h1>
<p>The simdjson library builds on compilers supporting the <a href="https://en.wikipedia.org/wiki/C%2B%2B11">C++11 standard</a>. It is also a strict requirement: we have no plan to support older C++ compilers.</p>
<p>We represent parsed strings in simdjson using the <code>std::string_view</code> class. It avoids the need to copy the data, as would be necessary with the <code>std::string</code> class. It also avoids the pitfalls of null-terminated C strings.</p>
<p>The <code>std::string_view</code> class has become standard as part of C++17 but it is not always available on compilers which only supports C++11. When we detect that <code>string_view</code> is natively available, we define the macro <code>SIMDJSON_HAS_STRING_VIEW</code>.</p>
<p>When we detect that it is unavailable, we use <a href="https://github.com/martinmoene/string-view-lite">string-view-lite</a> as a substitute. In such cases, we use the type alias <code>using string_view = nonstd::string_view;</code> to offer the same API, irrespective of the compiler and standard library. The macro <code>SIMDJSON_HAS_STRING_VIEW</code> will be <em>undefined</em> to indicate that we emulate <code>string_view</code>.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
C++17 Support</h1>
<p>While the simdjson library can be used in any project using C++ 11 and above, field iteration has special support C++ 17's destructuring syntax. For example:</p>
<div class="fragment"><div class="line">padded_string json = R&quot;(  { &quot;foo&quot;: 1, &quot;bar&quot;: 2 }  )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::object object;</div>
<div class="line">auto error = parser.parse(json).get(object);</div>
<div class="line">if (error) { cerr &lt;&lt; error &lt;&lt; endl; return; }</div>
<div class="line">for (auto [key, value] : object) {</div>
<div class="line">  cout &lt;&lt; key &lt;&lt; &quot; = &quot; &lt;&lt; value &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For comparison, here is the C++ 11 version of the same code:</p>
<div class="fragment"><div class="line">// C++ 11 version for comparison</div>
<div class="line">padded_string json = R&quot;(  { &quot;foo&quot;: 1, &quot;bar&quot;: 2 }  )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::object object;</div>
<div class="line">auto error = parser.parse(json).get(object);</div>
<div class="line">if (!error) { cerr &lt;&lt; error &lt;&lt; endl; return; }</div>
<div class="line">for (dom::key_value_pair field : object) {</div>
<div class="line">  cout &lt;&lt; field.key &lt;&lt; &quot; = &quot; &lt;&lt; field.value &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md27"></a>
Minifying JSON strings without parsing</h1>
<p>In some cases, you may have valid JSON strings that you do not wish to parse but that you wish to minify. That is, you wish to remove all unnecessary spaces. We have a fast function for this purpose (<code>simdjson::minify(const char * input, size_t length, const char * output, size_t&amp; new_length)</code>). This function does not validate your content, and it does not parse it. It is much faster than parsing the string and re-serializing it in minified form (<code>simdjson::minify(parser.parse())</code>). Usage is relatively simple. You must pass an input pointer with a length parameter, as well as an output pointer and an output length parameter (by reference). The output length parameter is not read, but written to. The output pointer should point to a valid memory region that is as large as the original string length. The input pointer and input length are read, but not written to.</p>
<div class="fragment"><div class="line">// Starts with a valid JSON document as a string.</div>
<div class="line">// It does not have to be null-terminated.</div>
<div class="line">const char * some_string = &quot;[ 1, 2, 3, 4] &quot;;</div>
<div class="line">size_t length = std::strlen(some_string);</div>
<div class="line">// Create a buffer to receive the minified string. Make sure that there is enough room (length bytes).</div>
<div class="line">std::unique_ptr&lt;char[]&gt; buffer{new char[length]};</div>
<div class="line">size_t new_length{}; // It will receive the minified length.</div>
<div class="line">auto error = simdjson::minify(some_string, length, buffer.get(), new_length);</div>
<div class="line">// The buffer variable now has &quot;[1,2,3,4]&quot; and new_length has value 9.</div>
</div><!-- fragment --><p>Though it does not validate the JSON input, it will detect when the document ends with an unterminated string. E.g., it would refuse to minify the string <code>"this string is not terminated</code> because of the missing final quote.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
UTF-8 validation (alone)</h1>
<p>The simdjson library has fast functions to validate UTF-8 strings. They are many times faster than most functions commonly found in libraries. You can use our fast functions, even if you do not care about JSON.</p>
<div class="fragment"><div class="line">const char * some_string = &quot;[ 1, 2, 3, 4] &quot;;</div>
<div class="line">size_t length = std::strlen(some_string);</div>
<div class="line">bool is_ok = simdjson::validate_utf8(some_string, length);</div>
</div><!-- fragment --><p>The UTF-8 validation function merely checks that the input is valid UTF-8: it works with strings in general, not just JSON strings.</p>
<p>Your input string does not need any padding. Any string will do. The <code>validate_utf8</code> function does not do any memory allocation on the heap, and it does not throw exceptions.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
JSON Pointer</h1>
<p>The simdjson library also supports <a href="https://tools.ietf.org/html/rfc6901">JSON pointer</a> through the <code>at_pointer()</code> method, letting you reach further down into the document in a single call:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::element cars = parser.parse(cars_json);</div>
<div class="line">cout &lt;&lt; cars.at_pointer(&quot;/0/tire_pressure/1&quot;) &lt;&lt; endl; // Prints 39.9</div>
</div><!-- fragment --><p>A JSON Path is a sequence of segments each starting with the '/' character. Within arrays, an integer index allows you to select the indexed node. Within objects, the string value of the key allows you to select the value. If your keys contain the characters '/' or '~', they must be escaped as '~1' and '~0' respectively. An empty JSON Path refers to the whole document.</p>
<p>We also extend the JSON Pointer support to include <em>relative</em> paths. You can apply a JSON path to any node and the path gets interpreted relatively, as if the currrent node were a whole JSON document.</p>
<p>Consider the following example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::element cars = parser.parse(cars_json);</div>
<div class="line">cout &lt;&lt; cars.at_pointer(&quot;/0/tire_pressure/1&quot;) &lt;&lt; endl; // Prints 39.9</div>
<div class="line">for (dom::element car_element : cars) {</div>
<div class="line">    dom::object car;</div>
<div class="line">    simdjson::error_code error;</div>
<div class="line">    if ((error = car_element.get(car))) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return; }</div>
<div class="line">    double x = car.at_pointer(&quot;/tire_pressure/1&quot;);</div>
<div class="line">    cout &lt;&lt; x &lt;&lt; endl; // Prints 39.9, 31 and 30</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md30"></a>
Error Handling</h1>
<p>All simdjson APIs that can fail return <code>simdjson_result&lt;T&gt;</code>, which is a &lt;value, error_code&gt; pair. You can retrieve the value with .get(), like so:</p>
<div class="fragment"><div class="line">dom::element doc;</div>
<div class="line">auto error = parser.parse(json).get(doc);</div>
<div class="line">if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
</div><!-- fragment --><p>When you use the code this way, it is your responsibility to check for error before using the result: if there is an error, the result value will not be valid and using it will caused undefined behavior.</p>
<p>We can write a "quick start" example where we attempt to parse the following JSON file and access some data, without triggering exceptions: </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;id&quot;: 505874924095815700</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;id&quot;: 505874922023837700</div>
<div class="line">    }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: {</div>
<div class="line">    &quot;count&quot;: 100</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our program loads the file, selects value corresponding to key "search_metadata" which expected to be an object, and then it selects the key "count" within that object.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">  simdjson::dom::parser parser;</div>
<div class="line">  simdjson::dom::element tweets;</div>
<div class="line">  auto error = parser.load(&quot;twitter.json&quot;).get(tweets);</div>
<div class="line">  if (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line"> </div>
<div class="line">  simdjson::dom::element res;</div>
<div class="line">  if ((error = tweets[&quot;search_metadata&quot;][&quot;count&quot;].get(res))) {</div>
<div class="line">    std::cerr &lt;&lt; &quot;could not access keys&quot; &lt;&lt; std::endl;</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; res &lt;&lt; &quot; results.&quot; &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following is a similar example where one wants to get the id of the first tweet without triggering exceptions. To do this, we use <code>["statuses"].at(0)["id"]</code>. We break that expression down:</p>
<ul>
<li>Get the list of tweets (the <code>"statuses"</code> key of the document) using <code>["statuses"]</code>). The result is expected to be an array.</li>
<li>Get the first tweet using <code>.at(0)</code>. The result is expected to be an object.</li>
<li>Get the id of the tweet using ["id"]. We expect the value to be a non-negative integer.</li>
</ul>
<p>Observe how we use the <code>at</code> method when querying an index into an array, and not the bracket operator.</p>
<div class="fragment"><div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">  simdjson::dom::parser parser;</div>
<div class="line">  simdjson::dom::element tweets;</div>
<div class="line">  auto error = parser.load(&quot;twitter.json&quot;).get(tweets);</div>
<div class="line">  if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">  uint64_t identifier;</div>
<div class="line">  error = tweets[&quot;statuses&quot;].at(0)[&quot;id&quot;].get(identifier);</div>
<div class="line">  if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">  std::cout &lt;&lt; identifier &lt;&lt; std::endl;</div>
<div class="line">  return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Error Handling Example</h2>
<p>This is how the example in "Using the Parsed JSON" could be written using only error code checking:</p>
<div class="fragment"><div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::array cars;</div>
<div class="line">auto error = parser.parse(cars_json).get(cars);</div>
<div class="line">if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line">// Iterating through an array of objects</div>
<div class="line">for (dom::element car_element : cars) {</div>
<div class="line">    dom::object car;</div>
<div class="line">    if ((error = car_element.get(car))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line">    // Accessing a field by name</div>
<div class="line">    std::string_view make, model;</div>
<div class="line">    if ((error = car[&quot;make&quot;].get(make))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    if ((error = car[&quot;model&quot;].get(model))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    cout &lt;&lt; &quot;Make/Model: &quot; &lt;&lt; make &lt;&lt; &quot;/&quot; &lt;&lt; model &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    // Casting a JSON element to an integer</div>
<div class="line">    uint64_t year;</div>
<div class="line">    if ((error = car[&quot;year&quot;].get(year))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    cout &lt;&lt; &quot;- This car is &quot; &lt;&lt; 2020 - year &lt;&lt; &quot;years old.&quot; &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    // Iterating through an array of floats</div>
<div class="line">    double total_tire_pressure = 0;</div>
<div class="line">    dom::array tire_pressure_array;</div>
<div class="line">    if ((error = car[&quot;tire_pressure&quot;].get(tire_pressure_array))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    for (dom::element tire_pressure_element : tire_pressure_array) {</div>
<div class="line">        double tire_pressure;</div>
<div class="line">        if ((error = tire_pressure_element.get(tire_pressure))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        total_tire_pressure += tire_pressure;</div>
<div class="line">    }</div>
<div class="line">    cout &lt;&lt; &quot;- Average tire pressure: &quot; &lt;&lt; (total_tire_pressure / 4) &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    // Writing out all the information about the car</div>
<div class="line">    for (auto field : car) {</div>
<div class="line">        cout &lt;&lt; &quot;- &quot; &lt;&lt; field.key &lt;&lt; &quot;: &quot; &lt;&lt; field.value &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is another example:</p>
<div class="fragment"><div class="line">auto abstract_json = R&quot;( [</div>
<div class="line">    {  &quot;12345&quot; : {&quot;a&quot;:12.34, &quot;b&quot;:56.78, &quot;c&quot;: 9998877}   },</div>
<div class="line">    {  &quot;12545&quot; : {&quot;a&quot;:11.44, &quot;b&quot;:12.78, &quot;c&quot;: 11111111}  }</div>
<div class="line">  ] )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">dom::array array;</div>
<div class="line">auto error = parser.parse(abstract_json).get(array);</div>
<div class="line">if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">// Iterate through an array of objects</div>
<div class="line">for (dom::element elem : array) {</div>
<div class="line">    dom::object obj;</div>
<div class="line">    if ((error = elem.get(obj))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">    for (auto &amp; key_value : obj) {</div>
<div class="line">        cout &lt;&lt; &quot;key: &quot; &lt;&lt; key_value.key &lt;&lt; &quot; : &quot;;</div>
<div class="line">        dom::object innerobj;</div>
<div class="line">        if ((error = key_value.value.get(innerobj))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line"> </div>
<div class="line">        double va, vb;</div>
<div class="line">        if ((error = innerobj[&quot;a&quot;].get(va))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        cout &lt;&lt; &quot;a: &quot; &lt;&lt; va &lt;&lt; &quot;, &quot;;</div>
<div class="line">        if ((error = innerobj[&quot;b&quot;].get(vc))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        cout &lt;&lt; &quot;b: &quot; &lt;&lt; vb &lt;&lt; &quot;, &quot;;</div>
<div class="line"> </div>
<div class="line">        int64_t vc;</div>
<div class="line">        if ((error = innerobj[&quot;c&quot;].get(vc))) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">        cout &lt;&lt; &quot;c: &quot; &lt;&lt; vc &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And another one:</p>
<div class="fragment"><div class="line">auto abstract_json = R&quot;(</div>
<div class="line">  {  &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } } )&quot;_padded;</div>
<div class="line">dom::parser parser;</div>
<div class="line">double v;</div>
<div class="line">auto error = parser.parse(abstract_json)[&quot;str&quot;][&quot;123&quot;][&quot;abc&quot;].get(v);</div>
<div class="line">if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
<div class="line">cout &lt;&lt; &quot;number: &quot; &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p>Notice how we can string several operations (<code>parser.parse(abstract_json)["str"]["123"]["abc"].get(v)</code>) and only check for the error once, a strategy we call <em>error chaining</em>.</p>
<p>The next two functions will take as input a JSON document containing an array with a single element, either a string or a number. They return true upon success.</p>
<div class="fragment"><div class="line">simdjson::dom::parser parser{};</div>
<div class="line"> </div>
<div class="line">bool parse_double(const char *j, double &amp;d) {</div>
<div class="line">  auto error = parser.parse(j, std::strlen(j))</div>
<div class="line">        .at(0)</div>
<div class="line">        .get(d, error);</div>
<div class="line">  if (error) { return false; }</div>
<div class="line">  return true;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">bool parse_string(const char *j, std::string &amp;s) {</div>
<div class="line">  std::string_view answer;</div>
<div class="line">  auto error = parser.parse(j,strlen(j))</div>
<div class="line">        .at(0)</div>
<div class="line">        .get(answer, error);</div>
<div class="line">  if (error) { return false; }</div>
<div class="line">  s.assign(answer.data(), answer.size());</div>
<div class="line">  return true;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Exceptions</h2>
<p>Users more comfortable with an exception flow may choose to directly cast the <code>simdjson_result&lt;T&gt;</code> to the desired type:</p>
<div class="fragment"><div class="line">dom::element doc = parser.parse(json); // Throws an exception if there was an error!</div>
</div><!-- fragment --><p>When used this way, a <code>simdjson_error</code> exception will be thrown if an error occurs, preventing the program from continuing if there was an error.</p>
<p>If one is willing to trigger exceptions, it is possible to write simpler code:</p>
<div class="fragment"><div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">  simdjson::dom::parser parser;</div>
<div class="line">  simdjson::dom::element tweets = parser.load(&quot;twitter.json&quot;);</div>
<div class="line">  std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; tweets[&quot;statuses&quot;].at(0)[&quot;id&quot;] &lt;&lt; std::endl;</div>
<div class="line">  return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
Tree Walking and JSON Element Types</h1>
<p>Sometimes you don't necessarily have a document with a known type, and are trying to generically inspect or walk over JSON elements. To do that, you can use iterators and the type() method. For example, here's a quick and dirty recursive function that verbosely prints the JSON document as JSON (* ignoring nuances like trailing commas and escaping strings, for brevity's sake):</p>
<div class="fragment"><div class="line">void print_json(dom::element element) {</div>
<div class="line">  switch (element.type()) {</div>
<div class="line">    case dom::element_type::ARRAY:</div>
<div class="line">      cout &lt;&lt; &quot;[&quot;;</div>
<div class="line">      for (dom::element child : dom::array(element)) {</div>
<div class="line">        print_json(child);</div>
<div class="line">        cout &lt;&lt; &quot;,&quot;;</div>
<div class="line">      }</div>
<div class="line">      cout &lt;&lt; &quot;]&quot;;</div>
<div class="line">      break;</div>
<div class="line">    case dom::element_type::OBJECT:</div>
<div class="line">      cout &lt;&lt; &quot;{&quot;;</div>
<div class="line">      for (dom::key_value_pair field : dom::object(element)) {</div>
<div class="line">        cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; field.key &lt;&lt; &quot;\&quot;: &quot;;</div>
<div class="line">        print_json(field.value);</div>
<div class="line">      }</div>
<div class="line">      cout &lt;&lt; &quot;}&quot;;</div>
<div class="line">      break;</div>
<div class="line">    case dom::element_type::INT64:</div>
<div class="line">      cout &lt;&lt; int64_t(element) &lt;&lt; endl;</div>
<div class="line">      break;</div>
<div class="line">    case dom::element_type::UINT64:</div>
<div class="line">      cout &lt;&lt; uint64_t(element) &lt;&lt; endl;</div>
<div class="line">      break;</div>
<div class="line">    case dom::element_type::DOUBLE:</div>
<div class="line">      cout &lt;&lt; double(element) &lt;&lt; endl;</div>
<div class="line">      break;</div>
<div class="line">    case dom::element_type::STRING:</div>
<div class="line">      cout &lt;&lt; std::string_view(element) &lt;&lt; endl;</div>
<div class="line">      break;</div>
<div class="line">    case dom::element_type::BOOL:</div>
<div class="line">      cout &lt;&lt; bool(element) &lt;&lt; endl;</div>
<div class="line">      break;</div>
<div class="line">    case dom::element_type::NULL_VALUE:</div>
<div class="line">      cout &lt;&lt; &quot;null&quot; &lt;&lt; endl;</div>
<div class="line">      break;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void basics_treewalk_1() {</div>
<div class="line">  dom::parser parser;</div>
<div class="line">  print_json(parser.load(&quot;twitter.json&quot;));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md34"></a>
Newline-Delimited JSON (ndjson) and JSON lines</h1>
<p>The simdjson library also support multithreaded JSON streaming through a large file containing many smaller JSON documents in either <a href="http://ndjson.org">ndjson</a> or <a href="http://jsonlines.org">JSON lines</a> format. If your JSON documents all contain arrays or objects, we even support direct file concatenation without whitespace. The concatenated file has no size restrictions (including larger than 4GB), though each individual document must be no larger than 4 GB.</p>
<p>Here is a simple example, given "x.json" with this content:</p>
<div class="fragment"><div class="line">{ &quot;foo&quot;: 1 }</div>
<div class="line">{ &quot;foo&quot;: 2 }</div>
<div class="line">{ &quot;foo&quot;: 3 }</div>
</div><!-- fragment --><div class="fragment"><div class="line">dom::parser parser;</div>
<div class="line">dom::document_stream docs = parser.load_many(&quot;x.json&quot;);</div>
<div class="line">for (dom::element doc : docs) {</div>
<div class="line">  cout &lt;&lt; doc[&quot;foo&quot;] &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line">// Prints 1 2 3</div>
</div><!-- fragment --><p>In-memory ndjson strings can be parsed as well, with <code>parser.parse_many(string)</code>:</p>
<div class="fragment"><div class="line">dom::parser parser;</div>
<div class="line">  auto json = R&quot;({ &quot;foo&quot;: 1 }</div>
<div class="line">{ &quot;foo&quot;: 2 }</div>
<div class="line">{ &quot;foo&quot;: 3 })&quot;_padded;</div>
<div class="line">dom::document_stream docs = parser.parse_many(json);</div>
<div class="line">for (dom::element doc : docs) {</div>
<div class="line">  cout &lt;&lt; doc[&quot;foo&quot;] &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line">// Prints 1 2 3</div>
</div><!-- fragment --><p>Unlike <code>parser.parse</code>, both <code>parser.load_many(filename)</code> and <code>parser.parse_many(string)</code> may parse "On-Demand" (lazily). That is, no parsing may have been done before you enter the loop <code>for (dom::element doc : docs) {</code> and you should expect the parser to only ever fully parse one JSON document at a time.</p>
<ol type="1">
<li>When calling <code>parser.load_many(filename)</code>, the file's content is loaded up in a memory buffer owned by the <code>parser</code>'s instance. Thus the file can be safely deleted after calling <code>parser.load_many(filename)</code> as the parser instance owns all of the data.</li>
<li>When calling <code>parser.parse_many(string)</code>, no copy is made of the provided string input. The provided memory buffer may be accessed each time a JSON document is parsed. Calling <code>parser.parse_many(string)</code> on a temporary string buffer (e.g., <code>docs = parser.parse_many("[1,2,3]"_padded)</code>) is unsafe (and will not compile) because the <code>document_stream</code> instance needs access to the buffer to return the JSON documents. In constrast, calling <code>doc = parser.parse("[1,2,3]"_padded)</code> is safe because <code>parser.parse</code> eagerly parses the input.</li>
</ol>
<p>Both <code>load_many</code> and <code>parse_many</code> take an optional parameter <code>size_t batch_size</code> which defines the window processing size. It is set by default to a large value (<code>1000000</code> corresponding to 1 MB). None of your JSON documents should exceed this window size, or else you will get the error <code>simdjson::CAPACITY</code>. You cannot set this window size larger than 4 GB: you will get the error <code>simdjson::CAPACITY</code>. The smaller the window size is, the less memory the function will use. Setting the window size too small (e.g., less than 100 kB) may also impact performance negatively. Leaving it to 1 MB is expected to be a good choice, unless you have some larger documents.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Thread Safety</h1>
<p>We built simdjson with thread safety in mind.</p>
<p>The simdjson library is single-threaded except for <code>parse_many</code> which may use secondary threads under its control when the library is compiled with thread support.</p>
<p>We recommend using one <code>dom::parser</code> object per thread in which case the library is thread-safe. It is unsafe to reuse a <code>dom::parser</code> object between different threads. The parsed results (<code>dom::document</code>, <code>dom::element</code>, <code>array</code>, <code>object</code>) depend on the <code>dom::parser</code>, etc. therefore it is also potentially unsafe to use the result of the parsing between different threads.</p>
<p>The CPU detection, which runs the first time parsing is attempted and switches to the fastest parser for your CPU, is transparent and thread-safe.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Backwards Compatibility</h1>
<p>The only header file supported by simdjson is <code>simdjson.h</code>. Older versions of simdjson published a number of other include files such as <code>document.h</code> or <code>ParsedJson.h</code> alongside <code>simdjson.h</code>; these headers may be moved or removed in future versions. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
