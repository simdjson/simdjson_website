<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: A Better Way to Parse Documents?</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdjson
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">A Better Way to Parse Documents? </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Whether we parse JSON or XML, or any other serialized format, there are relatively few common strategies:</p>
<ul>
<li>The most established approach is the construction of document-object-model (DOM).</li>
<li>Another established approach is a event-based approach (like SAX, SAJ).</li>
<li>Another popular approach is the schema-based deserialization model.</li>
</ul>
<p>We propose an approach that is as easy to use and often as flexible as the DOM approach, yet as fast and efficient as the schema-based or event-based approaches. We call this new approach "On Demand". The simdjson On Demand API offers a familiar, friendly DOM API and provides the performance of just-in-time parsing on top of the simdjson superior performance.</p>
<p>To achieve ease of use, we mimicked the <em>form</em> of a traditional DOM API: you can iterate over arrays, look up fields in objects, and extract native values like <code>double</code>, <code>uint64_t</code>, <code>string</code> and <code>bool</code>.</p>
<p>To achieve performance, we introduced some key limitations that make the DOM API <em>streaming</em>: array/object iteration cannot be restarted, and string/number values can only be parsed once. If these limitations are acceptable to you, the On Demand API could help you write maintainable applications with a computation efficiency that is difficult to surpass.</p>
<p>A code example illustrates our API from a programmer's point of view:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">for (auto tweet : doc[&quot;statuses&quot;]) {</div>
<div class="line">  std::string_view text        = tweet[&quot;text&quot;];</div>
<div class="line">  std::string_view screen_name = tweet[&quot;user&quot;][&quot;screen_name&quot;];</div>
<div class="line">  uint64_t         retweets    = tweet[&quot;retweet_count&quot;];</div>
<div class="line">  uint64_t         favorites   = tweet[&quot;favorite_count&quot;];</div>
<div class="line">  cout &lt;&lt; screen_name &lt;&lt; &quot; (&quot; &lt;&lt; retweets &lt;&lt; &quot; retweets / &quot; &lt;&lt; favorites &lt;&lt; &quot; favorites): &quot; &lt;&lt; text &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Such code would be apply to a JSON document such as the following JSON mimicking a sample result from the Twitter API:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;statuses&quot;: [{</div>
<div class="line">            &quot;text&quot;: &quot;@aym0566x \n\n名前:前田あゆみ\n第一印象:なんか怖っ！\n今の印象:とりあえずキモい。噛み合わない\n好きなところ:ぶすでキモいとこ😋✨✨\n思い出:んーーー、ありすぎ😊❤️\nLINE交換できる？:あぁ……ごめん✋\nトプ画をみて:照れますがな😘✨\n一言:お前は一生もんのダチ💖&quot;,</div>
<div class="line">            &quot;user&quot;: {</div>
<div class="line">                &quot;name&quot;: &quot;AYUMI&quot;,</div>
<div class="line">                &quot;screen_name&quot;: &quot;ayuu0123&quot;,</div>
<div class="line">                &quot;followers_count&quot;: 262,</div>
<div class="line">                &quot;friends_count&quot;: 252</div>
<div class="line">            },</div>
<div class="line">            &quot;retweet_count&quot;: 0,</div>
<div class="line">            &quot;favorite_count&quot;: 0</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            &quot;text&quot;: &quot;RT @KATANA77: えっそれは・・・（一同） http://t.co/PkCJAcSuYK&quot;,</div>
<div class="line">            &quot;user&quot;: {</div>
<div class="line">                &quot;name&quot;: &quot;RT&amp;ファボ魔のむっつんさっm&quot;,</div>
<div class="line">                &quot;screen_name&quot;: &quot;yuttari1998&quot;,</div>
<div class="line">                &quot;followers_count&quot;: 95,</div>
<div class="line">                &quot;friends_count&quot;: 158</div>
<div class="line">            },</div>
<div class="line">            &quot;retweet_count&quot;: 82,</div>
<div class="line">            &quot;favorite_count&quot;: 42</div>
<div class="line">        }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: {</div>
<div class="line">    &quot;count&quot;: 100,</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This streaming approach means that unused fields and values are not parsed or converted, thus saving space and time. In our example, the <code>"name"</code>, <code>"followers_count"</code>, and <code>"friends_count"</code> keys and matching values are skipped.</p>
<p>Further, the On Demand API does not parse a value <em>at all</em> until you try to convert it (e.g., to <code>double</code>, <code>int</code>, <code>string</code>, or <code>bool</code>). In our example, when accessing the key-value pair <code>"retweet_count": 82</code>, the parser may not convert the pair of characters <code>82</code> to the binary integer 82. Because the programmer specifies the data type, we avoid branch mispredictions related to data type determination and improve the performance.</p>
<p>We expect users of an On Demand API to work in terms of a JSON dialect, which is a set of expectations and specifications that come in addition to the <a href="https://www.rfc-editor.org/rfc/rfc8259.txt">JSON specification</a>. The On Demand approach is designed around several principles:</p>
<ul>
<li><b>Streaming (*):</b> It avoids preparsing values, keeping the memory usage and the latency down.</li>
<li><b>Forward-Only:</b> To prevent reiteration of the same values and to keep the number of variables down (literally), only a single index is maintained and everything uses it (even if you have nested for loops). This means when you are going through an array of arrays, for example, that the inner array loop will advance the index to the next comma, and the array can just pick it up and look at it.</li>
<li><b>Natural Iteration:</b> A JSON array or object can be iterated with a normal C++ for loop. Nested arrays and objects are supported by nested for loops.</li>
<li><b>Use-Specific Parsing:</b> Parsing is always specific to the type required by the programmer. For example, if the programmer asks for an unsigned integer, we just start parsing digits. If there were no digits, we toss an error. There are even different parsers for <code>double</code>, <code>uint64_t</code> and <code>int64_t</code> values. This use-specific parsing avoids the branchiness of a generic "type switch," and makes the code more inlineable and compact.</li>
<li><b>Validate What You Use:</b> On Demand deliberately validates the values you use and the structure leading to it, but nothing else. The goal is a guarantee that the value you asked for is the correct one and is not malformed: there must be no confusion over whether you got the right value.</li>
</ul>
<p>To understand why On Demand is different, it is helpful to review the major approaches to parsing and parser APIs in use today.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
DOM Parsers</h2>
<p>Many of the most usable, popular JSON APIs (including simdjson) deserialize into a <b>DOM</b>: an intermediate tree of objects, arrays and values. In this model, we convert the input data all at once into a tree-like structure (the DOM). The DOM is then accessed by the programmer like any other in-memory data structure. The resulting API let you refer to each array or object separately, using familiar techniques like iteration (<code>for (auto value : array)</code>) or indexing (<code>object["key"]</code>). In some cases, the values are even deserialized directly into familiar C++ constructs like vectors and maps.</p>
<p>The DOM approach is conceptually simple and "programmer friendly". Using the DOM tree is often easy enough that many users use the DOM as-is instead of creating their own custom data structures.</p>
<p>The DOM approach was the only way to parse JSON documents up to version 0.6 of the simdjson library. Our DOM API looks similar to our On Demand example, except it calls <code>parse</code> instead of <code>iterate</code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">dom::parser parser;</div>
<div class="line">auto doc = parser.parse(json);</div>
<div class="line">for (auto tweet : doc[&quot;statuses&quot;]) {</div>
<div class="line">  std::string_view text        = tweet[&quot;text&quot;];</div>
<div class="line">  std::string_view screen_name = tweet[&quot;user&quot;][&quot;screen_name&quot;];</div>
<div class="line">  uint64_t         retweets    = tweet[&quot;retweet_count&quot;];</div>
<div class="line">  cout &lt;&lt; screen_name &lt;&lt; &quot; (&quot; &lt;&lt; retweets &lt;&lt; &quot; retweets): &quot; &lt;&lt; text &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Pros of the DOM approach:</p><ul>
<li>Straightforward, programmer-friendly interface (arrays and objects).</li>
<li>Safe: all of the input data has been validated before it is accessed.</li>
<li>All of the JSON document is available at once to the programmer.</li>
</ul>
<p>Cons of the DOM approach:</p><ul>
<li>The memory usage scales linearly with the size of the input document.</li>
<li>Parses and stores everything, using memory and CPU cycles even on unused values.</li>
<li>Performance drain from <a href="#type-blindness">type blindness</a>.</li>
</ul>
<p>What the simdjson library demonstrates is that a DOM API may be quite fast indeed: we can parse files at speeds of several gigabytes per second. However, in some instances, it may be possible to achieve even higher speeds.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Event-Based Parsers (SAX, SAJ, etc.)</h2>
<p>The event-based model (originally from the "Streaming API for XML") uses streaming to eliminate the cost of parsing and storing the entire JSON. In the event-based model, a core JSON engine parses the JSON document piece by piece, but instead of stuffing values in a DOM tree, it passes each value to a callback function, letting the user decide for themselves how to handle it. In such a model, the programmer may need to provide functions for all possible events (a number, a string, a new object, a new array, the array ends, the object ends, and so on). This allows programmers to work with much larger files without running out of memory.</p>
<p>The drawback is complexity: event-based APIs generally have you define a single callback for each type (e.g. <code>string_field(std::string_view key, std::string_view value)</code>). Because of this, the programmer suffers from context blindness: when they find a string they have to check where it is before they know what to do with it. Is this string the text of the tweet, the screen name, or something else? Are we even in a tweet right now, or is this from some other place in the document entirely? Though an event-based approach may allow superior performance, it is demanding of the programmer who must efficiently keep track of its current state within the JSON input.</p>
<p>The following is event-based example of the Twitter problem we have reviewed in the DOM and On Demand examples. To make it short enough to use as an example at all, it has heavily redacted: it only solves a part of the problem (does not get user.screen_name), it has bugs (it does not handle sub-objects in a tweet at all), and it uses a theoretical, simple event-based API that minimizes ceremony.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct twitter_callbacks {</div>
<div class="line">  bool in_statuses;</div>
<div class="line">  bool in_tweet;</div>
<div class="line">  std::string_view text;</div>
<div class="line">  uint64_t         retweets;</div>
<div class="line">  uint64_t         favorites;</div>
<div class="line">  void start_object_field(std::string_view key) {</div>
<div class="line">    if (key == &quot;statuses&quot;) { in_statuses = true; }</div>
<div class="line">  }</div>
<div class="line">  void start_object() {</div>
<div class="line">    if (in_statuses) { in_tweet = true; }</div>
<div class="line">  }</div>
<div class="line">  void string_field(std::string_view key, std::string_view value) {</div>
<div class="line">    if (in_tweet &amp;&amp; key == &quot;text&quot;) { text = value; }</div>
<div class="line">  }</div>
<div class="line">  void number_field(std::string_view key, uint64_t value) {</div>
<div class="line">    if (in_tweet) {</div>
<div class="line">      if (key == &quot;retweet_count&quot;) { retweets = value; }</div>
<div class="line">      if (key == &quot;favorite_count&quot;) { favorites = value; }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  void end_object() {</div>
<div class="line">    if (in_tweet) {</div>
<div class="line">      cout &lt;&lt; &quot;[redacted] (&quot; &lt;&lt; retweets &lt;&lt; &quot; retweets / &quot; &lt;&lt; favorites &lt;&lt; &quot; favorites): &quot; &lt;&lt; text &lt;&lt; endl;</div>
<div class="line">      in_tweet = false;</div>
<div class="line">    } else if (in_statuses) {</div>
<div class="line">      in_statuses = false;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">sax::parser parser;</div>
<div class="line">parser.parse(twitter_callbacks());</div>
</div><!-- fragment --><p>This is a large amount of code, requiring mental gymnastics even to read. An actual implementation is harder to write and to maintain.</p>
<p>Pros of the event-based approach:</p><ul>
<li>Speed and space benefits from low, predictable memory usage.</li>
<li>Parsing can be done more lazily: the API can delegate work to the programmer for better performance.</li>
<li>It is highly flexible: given enough effort, most tasks can be accomplished efficiently.</li>
</ul>
<p>Cons of the event-based approach:</p><ul>
<li>Performance drain from context blindness (e.g., switch statements for "where am I in the document")</li>
<li>Difficult to use (high code complexity, high maintenance, difficult to debug)</li>
<li>Lacks the safety of DOM: malformed documents could be ingested.</li>
</ul>
<p>Though an event-based approach might have its niche uses, we believe that it is rarely ideally suited. We suspect that it is mostly used when performance and memory is a concern, and no other option (except DOM) is readily available.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Schema-Based Parser Generators</h2>
<p>In a schema-based model, the programmer provides a description of a data structure, and the parser constructs the data structure in question during parsing. These parsers take a schema&ndash;a description of your JSON, with field names, types, everything&ndash;and generate classes/structs in your language of choice, as well as a parser to deserialize the JSON into those structs. Some such parsers let you define your own data structures (<code>struct</code>) and they let a preprocessor inspects it and generates a custom JSON parser for it. Though not all of these schema-based parser generators generate a parser or even optimize for streaming, but they are <em>able</em> to in principle. Unlike the DOM and the event-based models, a schema-based approach assumes that the structure of the document is known at compile-time.</p>
<p>Pros of the schema-based approach:</p><ul>
<li>Ease of Use is on par with DOM</li>
<li>Parsers that generate iterators and lazy values in structs can keep memory pressure down to event-based levels.</li>
<li>Type Blindness can be entirely solved with specific parsers for each type, saving many branches.</li>
<li>Context Blindness can be solved, especially if object fields are required and in order, saving even more branches.</li>
<li>Can be made a safe as DOM: the input can be entirely validated prior to ingestion.</li>
</ul>
<p>Cons of the schema-based approach:</p><ul>
<li>It is less flexible than the DOM or event-based approaches, sometimes limited to a deserialization-to-objects scenario.</li>
<li>The structure of the data must be fully known at compile-time.</li>
</ul>
<h2><a class="anchor" id="autotoc_md62"></a>
Type Blindness and Branch Misprediction</h2>
<p>The DOM and event-based parsing model suffer from <b>type blindness</b>: even when the programmer knows exactly what fields and what types are in the JSON document, the parser does not. This means it has to look at each value blind with a big "switch" statement, asking "is this a number? A string? A boolean? An array? An object?"</p>
<p>In modern processors, this kind of switch statement can make your program run slower than it needs to because of the high cost of branch misprediction. Indeed, modern processor cores rely on speculative execution for speed. They "read ahead" in your program, predicting which instructions to run as soon as the data is available. A single-threaded program can execute 2, 3 or even more instructions per cycle&ndash;largely because of speculative execution.</p>
<p>Unfortunately, when the processor mispredicts the instructions, typically due to a mispredicted branch, all of the work done from the misprediction has be discarded and started anew. The processor may have been executing 3 or 4 instructions per cycle, and consuming the corresponding power, but all of the work may have been wasteful.</p>
<p>Type blindness means that the processor has to guess, for every JSON value, whether it will be an array, an object, number, string or boolean since these correspond to distinct code paths. Though some JSON files have predictable content, we find in practice that many JSON files stress the branch prediction. Though branch predictors improve with each new generation of processors, the cost of branch mispredictions also tends to increase as pipelines expand, and the processors become able to schedule longer streams of instructions.</p>
<p>On Demand parsing is tailor-made to solve this problem at the source, parsing values only after the user declares their type by asking for a <code>double</code>, an <code>int</code>, a <code>string</code>, etc. It attempts to do so while preserving most of the flexibility of DOM parsing.</p>
<h1><a class="anchor" id="autotoc_md63"></a>
Algorithm</h1>
<p>To help visualize the algorithm, we'll walk through the example C++ given at the top, for this JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md64"></a>
Starting the iteration</h2>
<ol type="1">
<li><p class="startli">First, we declare a parser object that keeps internal buffers necessary for parsing. This can be reused to parse multiple JSON files, so you do not pay the high cost of allocating memory every time (and so it can stay in cache!).</p>
<p class="startli">This declaration does not allocate any memory; that will happen in the next step.</p>
</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  ondemand::parser parser;</div>
</div><!-- fragment --><ol type="1">
<li>We then start iterating the JSON document by allocating internal parser buffers, preprocessing the JSON, and initializing the iterator.</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  auto doc = parser.iterate(json);</div>
</div><!-- fragment --><p>Since this is the first time this parser has been used, <code>iterate()</code> first allocates internal parser buffers if this is the first time through. When reusing an existing parser, allocation only happens if the new document is bigger than internal buffers can handle. The On Demand API only ever allocates memory in the <code>iterate()</code> function call.</p>
<p>The simdjson library then preprocesses the JSON text at high speed, finding all tokens (i.e. the starting position of any JSON value, as well as any important operators like <code>,</code>, <code>:</code>, <code>]</code> or <code>}</code>).</p>
<p>Finally, a <code>document</code> iterator is created, initialized at the position of the first value in the <code>json</code> text input. The document iterator is bumped forward by array / object iterators and object[] lookup, and must be kept around until iteration is complete.</p>
<p>This operation can fail as this stage if the document in invalid! The result type is <code>simdjson_result&lt;document&gt;</code>. The simdjson library uses <code>simdjson_result</code> when a value needs to be returned by a function that can fail given improper inputs. The <code>simdjson_result</code> value contain an <code>error_code</code> and a <code>document</code>, and it was designed to allow you to use either error code checking or C++ exceptions via a direct cast <code>document(parser.iterate(json))</code> you can use <code>get()</code> to check the error and cast to a value, or cast directly to a value. However, the simdjson library rely on error chaining, so it is possible to delay error checks: we shall shortly explain error chaining more fully.</p>
<blockquote class="doxtable">
<p>NOTE: You should always have such a <code>document</code> instance (here <code>doc</code>) and it should remain in scope for the duration of your parsing function. E.g., you should not use the returned document as a temporary (e.g., <code>auto x = parser.iterate(json).get_object();</code>) followed by other operations as the destruction of the <code>document</code> instance makes all of the derived instances ill-defined. </p>
</blockquote>
<p>At this point, the iterator is at the start of the JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">^ (depth 1)</div>
<div class="line"> </div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>We iterate over the "statuses" field using a typical C++ iterator, reading past the initial <code>{ "statuses": [ {</code>.</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  for (ondemand::object tweet : doc[&quot;statuses&quot;]) {</div>
</div><!-- fragment --><p>This shorthand does a lot, and it is helpful to see what it expands to. Comments in front of each one explain what's going on:</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  // Validate that the top-level value is an object: check for {. Increase depth to 2 (root &gt; field).</div>
<div class="line">  ondemand::object top = doc.get_object();</div>
<div class="line"> </div>
<div class="line">  // Find the field statuses by:</div>
<div class="line">  // 1. Check whether the object is empty (check for }). (We do not really need to do this unless</div>
<div class="line">  //    the key lookup fails!)</div>
<div class="line">  // 2. Check if we&#39;re at the field by looking for the string &quot;statuses&quot; using byte-by-byte comparison.</div>
<div class="line">  // 3. Validate that there is a `:` after it.</div>
<div class="line">  auto tweets_field = top[&quot;statuses&quot;];</div>
<div class="line"> </div>
<div class="line">  // - Validate that the field value is an array: check for [</div>
<div class="line">  // - If the array is empty (if there is a ] next), decrease depth back to 0.</div>
<div class="line">  // - If not, increase depth to 3 (root &gt; statuses &gt; tweet).</div>
<div class="line">  ondemand::array tweets = tweets_field.get_array();</div>
<div class="line">  // These three method calls do nothing substantial (the real checking happens in get_array() and ++)</div>
<div class="line">  // != checks whether the array is finished (if we found a ] and decreased depth back to 0).</div>
<div class="line">  ondemand::array_iterator tweets_iter = tweets.begin();</div>
<div class="line">  while (tweets_iter != tweets.end()) {</div>
<div class="line">    auto tweet_value = *tweets_iter;</div>
<div class="line"> </div>
<div class="line">    // - Validate that the array element is an object: check for {</div>
<div class="line">    // - If the object is empty (if there is a } next), decrease depth back to 1.</div>
<div class="line">    // - If not, increase depth to 4 (root &gt; statuses &gt; tweet &gt; field).</div>
<div class="line">    ondemand::object tweet = tweet_value.get_object();</div>
<div class="line">    ...</div>
<div class="line">  }</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: What is not explained in this code expansion is <em>error chaining</em>. Generally, you can use <code>document</code> methods on a <code>simdjson_result&lt;...&gt;</code> value; any errors will just be passed down the chain. Many method calls can be chained in this manner. So <code>for (object tweet : doc["statuses"])</code>, which is the equivalent of <code>object tweet = *(doc.get_object()["statuses"].get_array().begin()).get_object()</code>, could fail in any of 6 method calls, and the error will only be checked at the end, when you attempt to cast the final <code>simdjson_result&lt;object&gt;</code> to object. Upon casting, an exception is thrown if there was an error. </p>
</blockquote>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">      ^ (depth 4 - root &gt; statuses &gt; tweet &gt; field)</div>
<div class="line"> </div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>We get the <code>"text"</code> field as a string.</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  std::string_view text        = tweet[&quot;text&quot;];</div>
</div><!-- fragment --><p>First, <code>["text"]</code> skips the <code>"id"</code> field because it does not match: skips the key, <code>:</code> and value (<code>1</code>). We then check whether there are more fields by looking for either <code>,</code> or <code>}</code>.</p>
<p>The second field is matched (<code>"text"</code>), so we validate the <code>:</code> and move to the actual value.</p>
<blockquote class="doxtable">
<p>NOTE: <code>["text"]</code> does a <em>raw match</em>, comparing the key directly against the raw JSON. This allows simdjson to do field lookup very, very quickly when the keys you want to match have letters, numbers and punctuation. However, this means that fields with escapes in them will not be matched. </p>
</blockquote>
<p>To convert to a string, we check for <code>"</code> and use simdjson's fast unescaping algorithm to copy <code>first!</code> (plus a terminating <code>\0</code>) into a buffer managed by the <code>document</code>. This buffer stores all strings from a single iteration. The next string will be written after the <code>\0</code>.</p>
<p>A <code>string_view</code> is returned which points to that buffer, and contains the length.</p>
<p>We advance to the comma, and decrease depth to 3 (root &gt; statuses &gt; tweet).</p>
<p>At this point, we are here in the JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">                               ^ (depth 2 - root &gt; statuses &gt; tweet)</div>
<div class="line"> </div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>We get the <code>"screen_name"</code> from the <code>"user"</code> object.</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">     ondemand::object user        = tweet[&quot;user&quot;];</div>
<div class="line">     screen_name                  = user[&quot;screen_name&quot;];</div>
</div><!-- fragment --><p>First, <code>["user"]</code> finds the <code>,</code>, discovers the next key is <code>"user"</code>, validates that the <code>:</code> is there, and increases depth to 4 (root &gt; statuses &gt; tweet &gt; field).</p>
<p>Next, the cast to ondemand::object checks for <code>{</code> and increases depth to 5 (root &gt; statuses &gt; tweet &gt; user &gt; field).</p>
<p><code>["screen_name"]</code> finds the first field <code>"screen_name"</code> and validates the <code>:</code>.</p>
<p>To convert the result to usable string (i.e., the screen name <code>lemire</code>), the characters are written to the document's string buffer (after possibly escaping them), which now has <em>two</em> string_views pointing into it, and looks like <code>first!\0lemire\0</code>.</p>
<p>The iterator advances to the comma and decreases depth back to 4 (root &gt; statuses &gt; tweet &gt; user).</p>
<p>At this point, the iterator is here in the JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">                                                                  ^ (depth 4 - root &gt; statuses &gt; tweet &gt; user)</div>
<div class="line"> </div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>We get <code>"retweet_count"</code> as an unsigned integer.</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  uint64_t         retweets    = tweet[&quot;retweet_count&quot;];</div>
</div><!-- fragment --><p>First, <code>["retweet_count"]</code> checks whether the previous field value is finished (if it was, depth would be 3 (root &gt; statuses &gt; tweet). Since it's not, we skip JSON until depth is 3. This brings the iterator to the <code>,</code> after the user object:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">                                                                  ^ (depth 4 - root &gt; statuses &gt; tweet &gt; user)</div>
<div class="line"> </div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Because of the cast to uint64_t, simdjson knows it's parsing an unsigned integer. This lets us use a fast parser which <em>only</em> knows how to parse digits. It validates that it is an integer by rejecting negative numbers, strings, and other values based on the fact that they are not the digits 0-9. This type specificity is part of why parsing with on demand is so fast: you lose all the code that has to understand those other types.</p>
<p>The iterator is advanced to the <code>}</code>, and depth decreased back to 3 (root &gt; statuses &gt; tweet).</p>
<p>At this point, we are here in the JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">                                                                                                            ^ (depth 3 - root &gt; statuses &gt; tweet)</div>
<div class="line"> </div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>We loop to the next tweet.</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  for (ondemand::object tweet : doc[&quot;statuses&quot;]) {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The relevant parts of the loop are:</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  while (iter != statuses.end()) {</div>
<div class="line">    ondemand::object tweet = *iter;</div>
<div class="line">    ...</div>
<div class="line">    iter++;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>First, <code>iter++</code> (remember, this is the array of tweets) checks whether the previous object was fully iterated. It was not&ndash;depth is 3 (root &gt; statuses &gt; tweet), so we skip until it's 2&ndash;which in this case just means consuming the <code>}</code>, leaving the iterator at the next comma. Depth is now 2 (root &gt; statuses).</p>
<p>Next, <code>iter++</code> finds the <code>,</code> and advances past it to the <code>{</code>, increasing depth to 3 (root &gt; statuses &gt; tweet).</p>
<p>Finally, <code>ondemand::object tweet = *iter</code> validates the <code>{</code> and increases depth to 4 (root &gt; statuses &gt; tweet &gt; field). This leaves the iterator here:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">                                                                                                            ^ (depth 3 - root &gt; statuses &gt; tweet)</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>This tweet is processed just like the previous one, leaving the iterator here:</li>
</ol>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">                                                                                                            ^ (depth 3 - root &gt; statuses &gt; tweet)</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>The loop ends. Recall the relevant parts of the statuses loop:</li>
</ol>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">  while (iter != statuses.end()) {</div>
<div class="line">    ondemand::object tweet = *iter;</div>
<div class="line">    ...</div>
<div class="line">    iter++;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>First, <code>iter++</code> finishes up any children, consuming the <code>}</code> and leaving depth at 2 (root &gt; statuses).</p>
<p>Next, <code>iter++</code> notices the <code>]</code> and ends the array by decreasing depth to 1. This leaves the iterator here in the JSON:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    { &quot;id&quot;: 1, &quot;text&quot;: &quot;first!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;lemire&quot;, &quot;name&quot;: &quot;Daniel&quot; }, &quot;retweet_count&quot;: 40 },</div>
<div class="line">    { &quot;id&quot;: 2, &quot;text&quot;: &quot;second!&quot;, &quot;user&quot;: { &quot;screen_name&quot;: &quot;jkeiser2&quot;, &quot;name&quot;: &quot;John&quot; }, &quot;retweet_count&quot;: 3 }</div>
<div class="line">  ],</div>
<div class="line">   ^ (depth 1 - root)</div>
<div class="line">  &quot;search_metadata&quot;: { &quot;count&quot;: 2 }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li><p class="startli">The remainder of the file is skipped.</p>
<p class="startli">Because no more action is taken, JSON processing stops: processing only occurs when you ask for values.</p>
<p class="startli">This means you can very efficiently do things like read a single value from a JSON file, or take the top N, for example. It also means the things you don't use won't be fully validated. This is a general principle of On Demand: don't validate what you don't use. We still fully validate values you do use, however, as well as the objects and arrays that lead to them, so that you can be sure you get the information you need.</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md65"></a>
Design Features</h1>
<h2><a class="anchor" id="autotoc_md66"></a>
String Parsing</h2>
<p>When the user requests strings, we unescape them to a single string buffer much like the DOM parser so that users enjoy the same string performance as the core simdjson. We do not write the length to the string buffer, however; that is stored in the <code>string_view</code> instance we return to the user.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> ondemand::parser parser;</div>
<div class="line"> auto doc = parser.iterate(json);</div>
<div class="line"> std::set&lt;std::string_view&gt; default_users;</div>
<div class="line"> ondemand::array tweets = doc[&quot;statuses&quot;].get_array();</div>
<div class="line"> for (auto tweet_value : tweets) {</div>
<div class="line">   auto tweet = tweet_value.get_object();</div>
<div class="line">   ondemand::object user = tweet[&quot;user&quot;].get_object();</div>
<div class="line">   std::string_view screen_name = user[&quot;screen_name&quot;].get_string();</div>
<div class="line">   bool default_profile = user[&quot;default_profile&quot;].get_bool();</div>
<div class="line">   if (default_profile) { default_users.insert(screen_name); }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>By using <code>string_view</code> instances, we avoid the high cost of allocating many small strings (as would be the case with <code>std::string</code>) but be mindful that the life cycle of these <code>string_view</code> instances is tied to the parser instance. If the parser instance is destroyed or reused for a new JSON document, these strings are no longer valid.</p>
<p>We iterate through object instances using <code>field</code> instances which represent key-value pairs. The value is accessible by the <code>value()</code> method whereas the key is accessible by the <code>key()</code> method. The keys are treated differently than values are made available as as special type <code>raw_json_string</code> which is a lightweight type that is meant to be used on a temporary basis, amost solely for direct raw ASCII comparisons: <code>key().raw()</code> provides direct access to the unescaped string. You can compare <code>key()</code> with unescaped C strings (e.g., <code>key()=="test"</code>). It is expected that the provided string is a valid JSON string. Importantly, the C string must not contain an unescaped quote character (<code>"</code>). For speed, the comparison is done byte-by-byte without handling the escaped characters. If you occasionally need to access and store the unescaped key values, you may use the <code>unescaped_key()</code> method. Once you have called <code>unescaped_key()</code> method, neither the <code>key()</code> nor the <code>unescaped_key()</code> methods should be called: the current field instance has no longer a key (that is by design). Like other strings, the resulting <code>std::string_view</code> generated from the <code>unescaped_key()</code> method has a lifecycle tied to the <code>parser</code> instance: once the parser is destroyed or reused with another document, the <code>std::string_view</code> instance becomes invalid.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">for(auto field : doc.get_object())  {</div>
<div class="line">      std::string_view keyv = field.unescaped_key();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md67"></a>
Iteration Safety</h2>
<p>The On Demand API is powerful. To compensate, we add some safeguards to ensure that it can be used without fear in production systems:</p>
<ul>
<li>If the value fails to be parsed as one type, the program can try to parse it as something else until the program succeeds. Thus the programmer can engineer fall back routines.</li>
<li>If the value succeeds in being parsed or converted to a type, the program cannot try again. An attempt to parse the same node twice will cause the program to abort. We put this safety measure in the API to prevent double iteration of an array which would cause inconsistent iterator state or double-unescaping a string which may cause memory overruns if done.</li>
<li>Guaranteed Iteration: If you discard a value without using it&ndash;perhaps you just wanted to know if it was <code>nullptr</code> but did not care what the actual value was&ndash;it will iterate. The destructor automates the iteration.</li>
</ul>
<p>Some care is needed when using the On Demand API in scenarios where you need to access several sibling arrays or objects because only one object or array can be active at any one time. Let us consider the following example:</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line">   ondemand::parser parser;</div>
<div class="line">   const padded_string json = R&quot;({ &quot;parent&quot;: {&quot;child1&quot;: {&quot;name&quot;: &quot;John&quot;} , &quot;child2&quot;: {&quot;name&quot;: &quot;Daniel&quot;}} })&quot;_padded;</div>
<div class="line">   auto doc = parser.iterate(json);</div>
<div class="line">   ondemand::object parent = doc[&quot;parent&quot;];</div>
<div class="line">   // parent owns the focus</div>
<div class="line">   ondemand::object c1 = parent[&quot;child1&quot;];</div>
<div class="line">   // c1 owns the focus</div>
<div class="line">   //</div>
<div class="line">   if(std::string_view(c1[&quot;name&quot;]) != &quot;John&quot;) { ... }</div>
<div class="line">   // c2 attempts to grab the focus from parent but fails</div>
<div class="line">   ondemand::object c2 = parent[&quot;child2&quot;];</div>
<div class="line">   // c2 is now in an unsafe state and the following line would be unsafe</div>
<div class="line">   // if(std::string_view(c2[&quot;name&quot;]) != &quot;Daniel&quot;) { return false; }</div>
</div><!-- fragment --> <pre class="fragment">A correct usage is given by the following example:
</pre> <div class="fragment"><div class="line">{C++}</div>
<div class="line">   ondemand::parser parser;</div>
<div class="line">   const padded_string json = R&quot;({ &quot;parent&quot;: {&quot;child1&quot;: {&quot;name&quot;: &quot;John&quot;} , &quot;child2&quot;: {&quot;name&quot;: &quot;Daniel&quot;}} })&quot;_padded;</div>
<div class="line">   auto doc = parser.iterate(json);</div>
<div class="line">   ondemand::object parent = doc[&quot;parent&quot;];</div>
<div class="line">   // At this point, parent owns the focus</div>
<div class="line">   {</div>
<div class="line">     ondemand::object c1 = parent[&quot;child1&quot;];</div>
<div class="line">     // c1 grabbed the focus from parent</div>
<div class="line">     if(std::string_view(c1[&quot;name&quot;]) != &quot;John&quot;) { return false; }</div>
<div class="line">   }</div>
<div class="line">   // c1 went out of scope, so its destructor was called and the focus</div>
<div class="line">   // was handed back to parent.</div>
<div class="line">   {</div>
<div class="line">     ondemand::object c2 = parent[&quot;child2&quot;];</div>
<div class="line">     // c2 grabbed the focus from parent</div>
<div class="line">     // the following is safe:</div>
<div class="line">     if(std::string_view(c2[&quot;name&quot;]) != &quot;Daniel&quot;) { return false; }</div>
<div class="line">   }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
Benefits of the On Demand Approach</h2>
<p>We expect that the On Demand approach has many of the performance benefits of the schema-based approach, while providing a flexibility that is similar to that of the DOM-based approach.</p>
<ul>
<li>Faster than DOM in some cases. Reduced memory usage.</li>
<li>Straightforward, programmer-friendly interface (arrays and objects).</li>
<li>Highly expressive, beyond deserialization and pointer queries: many tasks can be accomplished with little code.</li>
</ul>
<h2><a class="anchor" id="autotoc_md69"></a>
Limitations of the On Demand Approach</h2>
<p>The On Demand approach has some limitations:</p>
<ul>
<li>Because it operates in streaming mode, you only have access to the current element in the JSON document. Furthermore, the document is traversed in order so the code is sensitive to the order of the JSON nodes in the same manner as an event-based approach (e.g., SAX). (The one exception to this is field lookup, which is more <em>performant</em> when the order of lookups matches the order of fields in the document, but which will still work with out-of-order fields, with a performance hit.)</li>
<li>The On Demand approach is less safe than DOM: we only validate the components of the JSON document that are used and it is possible to begin ingesting an invalid document only to find out later that the document is invalid. Are you fine ingesting a large JSON document that starts with well formed JSON but ends with invalid JSON content?</li>
</ul>
<p>There are currently additional technical limitations which we expect to resolve in future releases of the simdjson library:</p>
<ul>
<li>The simdjson library offers runtime dispatching which allows you to compile one binary and have it run at full speed on different processors, taking advantage of the specific features of the processor. The On Demand API has limited runtime dispatch support. Under x64 systems, to fully benefit from the On Demand API, we recommend that you compile your code for a specific processor. E.g., if your processor supports AVX2 instructions, you should compile your binary executable with AVX2 instruction support (by using your compiler's commands). If you are sufficiently technically proficient, you can implement runtime dispatching within your application, by compiling your On Demand code for different processors.</li>
<li>There is an initial phase which scans the entire document quickly, irrespective of the size of the document. We plan to break this phase into distinct steps for large files in a future release as we have done with other components of our API (e.g., <code>parse_many</code>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md70"></a>
Applicability of the On Demand Approach</h2>
<p>At this time we recommend the On Demand API in the following cases:</p>
<ol type="1">
<li>The 64-bit hardware (CPU) used to run the software is known at compile time. If you need runtime dispatching because you cannot be certain of the hardware used to run your software, you will be better served with the core simdjson API. (This only applies to x64 (AMD/Intel). On 64-bit ARM hardware, runtime dispatching is unnecessary.)</li>
<li>The used parts of JSON files do not need to be validated and the layout of the nodes follows a strict JSON dialect. If you are receiving JSON from other systems, you might be better served with core simdjson API as it fully validates the JSON inputs and allows you to navigate through the document at will.</li>
<li>Speed and efficiency are of the utmost importance. Keep in mind that the core simdjson API is highly efficient so adopting the On Demand API is not necessary for high efficiency.</li>
<li>As a developer, you value a clean, flexible and maintainable API.</li>
</ol>
<p>Good applications for the On Demand API might be:</p>
<ul>
<li>You are working from pre-existing large JSON files that have been vetted. You expect them to be well formed according to a known JSON dialect and to have a consistent layout. For example, you might be doing biomedical research or machine learning on top of static data dumps in JSON.</li>
<li>Both the generation and the consumption of JSON data is within your system. Your team controls both the software that produces the JSON and the software the parses it, your team knows and control the hardware. Thus you can fully test your system.</li>
<li>You are working with stable JSON APIs which have a consistent layout and JSON dialect.</li>
</ul>
<h1><a class="anchor" id="autotoc_md71"></a>
Checking Your CPU Selection (x64 systems)</h1>
<p>The On Demand API uses advanced architecture-specific code for many common processors to make JSON preprocessing and string parsing faster. By default, however, most c++ compilers will compile to the least common denominator (since the program could theoretically be run anywhere). Since On Demand is inlined into your own code, it cannot always use these advanced versions unless the compiler is told to target them.</p>
<p>On relevant systems, the On Demand API provides some support for runtime dispatching: that is, it will attempt to detect, at runtime, the instructions that your processor supports and optimize the code accordingly. However, it cannot always make full use of the features of your processor.</p>
<p>Some users wish to run at the best possible speed. Under recent Intel and AMD processors, these users should take additional steps to verify that their code is well optimized.</p>
<p>Given that the On Demand API offer limited runtime dispatching, it matters that your code is compiled against a specific CPU target. You should verify that the code is compiled against the target you expect. Thankfully, the simdjson library will tell you exactly what it detects as an implementation: <code>haswell</code> (AVX2 x64 processors), <code>westmere</code> (SSE4 x64 processors), <code>arm64</code> (64-bit ARM), <code>ppc64</code> (64-bit POWER), <code>fallback</code> (others). Under x64 processors, many programmers will want to target <code>haswell</code> whereas under ARM, most programmers will want to target <code>arm64</code> (and it should do so automatically). The <code>fallback</code> is probably only good for testing purposes, not for deployment.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> std::cout &lt;&lt; simdjson::builtin_implementation()-&gt;name() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>If the <code><a class="el" href="namespacesimdjson.html#af63210cc51d5c99ad84958daf9812e63" title="Represents the best statically linked simdjson implementation that can be used by the compiling progr...">simdjson::builtin_implementation()</a>-&gt;name()</code> call does not return the architecture you wish to target, you may need to pass flags to your compiler.</p>
<p>If you are using CMake for your C++ project, then you can pass compilation flags to your compiler by using the <code>CMAKE_CXX_FLAGS</code> variable:</p>
<div class="fragment"><div class="line">cmake  -DCMAKE_CXX_FLAGS=&quot;-march=haswell&quot; -B build_haswell</div>
<div class="line">cmake --build build_haswell</div>
</div><!-- fragment --><p>You can also pass the flags directly to your compiler when compiling 'by hand':</p>
<div class="fragment"><div class="line">c++ -march=haswell -O3 myproject.cpp simdjson.cpp</div>
</div><!-- fragment --><p>In these examples, the <code>-march=haswell</code> flags targets a haswell processor and the resulting binary will run on processors that support all features of the haswell processors.</p>
<p>Instead of specifying a specific microarchitecture, you can let your compiler do the work. The <code>-march=native</code> flags says "target the current computer," which is a reasonable default for many applications which both compile and run on the same processor.</p>
<p>Passing <code>-march=native</code> to the compiler may make On Demand faster by allowing it to use optimizations specific to your machine. You cannot do this, however, if you are compiling code that might be run on less advanced machines. That is, be mindful that when compiling with the <code>-march=native</code> flag, the resulting binary will run on the current system but may not run on other systems (e.g., on an old processor).</p>
<p>If you are compiling on an ARM or POWER system, you do not need to be concerned with CPU selection during compilation. The <code>-march=native</code> flag useful for best performance on x64 (e.g., Intel) systems but it is generally unsupported on some platforms such as ARM (aarch64) or POWER. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
