<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: simdjson::dom::parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdjson
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>simdjson</b></li><li class="navelem"><b>dom</b></li><li class="navelem"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsimdjson_1_1dom_1_1parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">simdjson::dom::parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A persistent document parser.  
 <a href="classsimdjson_1_1dom_1_1parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="document_8h_source.html">document.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a19a5c0e2e4383019b496f950eb783c3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a19a5c0e2e4383019b496f950eb783c3b">InvalidJSON</a> = <a class="el" href="structsimdjson_1_1simdjson__error.html">simdjson_error</a></td></tr>
<tr class="separator:a19a5c0e2e4383019b496f950eb783c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27f96e41ca560e88b015e07490b4ab52"><td class="memItemLeft" align="right" valign="top">really_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a27f96e41ca560e88b015e07490b4ab52">parser</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6b68d9202cd9aa595c2c505e09deb2b2">max_capacity</a>=SIMDJSON_MAXSIZE_BYTES, size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>=DEFAULT_MAX_DEPTH) noexcept</td></tr>
<tr class="memdesc:a27f96e41ca560e88b015e07490b4ab52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a JSON parser.  <a href="classsimdjson_1_1dom_1_1parser.html#a27f96e41ca560e88b015e07490b4ab52">More...</a><br /></td></tr>
<tr class="separator:a27f96e41ca560e88b015e07490b4ab52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48211f320af02b58dc3d0505059844"><td class="memItemLeft" align="right" valign="top"><a id="aeb48211f320af02b58dc3d0505059844"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#aeb48211f320af02b58dc3d0505059844">~parser</a> ()=default</td></tr>
<tr class="memdesc:aeb48211f320af02b58dc3d0505059844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the JSON parser. <br /></td></tr>
<tr class="separator:aeb48211f320af02b58dc3d0505059844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4285c54961cf32b0815527d662e2b7a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a4285c54961cf32b0815527d662e2b7a1">parser</a> (<a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a4285c54961cf32b0815527d662e2b7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take another parser's buffers and state.  <a href="classsimdjson_1_1dom_1_1parser.html#a4285c54961cf32b0815527d662e2b7a1">More...</a><br /></td></tr>
<tr class="separator:a4285c54961cf32b0815527d662e2b7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e053daae3f5197f7c6168b505e2c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#ab85e053daae3f5197f7c6168b505e2c4">operator=</a> (<a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ab85e053daae3f5197f7c6168b505e2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take another parser's buffers and state.  <a href="classsimdjson_1_1dom_1_1parser.html#ab85e053daae3f5197f7c6168b505e2c4">More...</a><br /></td></tr>
<tr class="separator:ab85e053daae3f5197f7c6168b505e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5160192e89c4fa75d92819cde9750a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#af5160192e89c4fa75d92819cde9750a9">load</a> (const std::string &amp;path) noexcept</td></tr>
<tr class="memdesc:af5160192e89c4fa75d92819cde9750a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a JSON document from a file and return a reference to it.  <a href="classsimdjson_1_1dom_1_1parser.html#af5160192e89c4fa75d92819cde9750a9">More...</a><br /></td></tr>
<tr class="separator:af5160192e89c4fa75d92819cde9750a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b8b3e4587e5200ce45e96cf474eed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a55b8b3e4587e5200ce45e96cf474eed3">load_many</a> (const std::string &amp;path, size_t batch_size=DEFAULT_BATCH_SIZE) noexcept</td></tr>
<tr class="memdesc:a55b8b3e4587e5200ce45e96cf474eed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a file containing many JSON documents.  <a href="classsimdjson_1_1dom_1_1parser.html#a55b8b3e4587e5200ce45e96cf474eed3">More...</a><br /></td></tr>
<tr class="separator:a55b8b3e4587e5200ce45e96cf474eed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4f62b70475ec8067196ac53dfdbead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead">parse</a> (const uint8_t *buf, size_t len, bool realloc_if_needed=true) noexcept</td></tr>
<tr class="memdesc:adb4f62b70475ec8067196ac53dfdbead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a JSON document and return a temporary reference to it.  <a href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead">More...</a><br /></td></tr>
<tr class="separator:adb4f62b70475ec8067196ac53dfdbead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf903ec97071a5364a89068377d17b5"><td class="memItemLeft" align="right" valign="top">really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#aedf903ec97071a5364a89068377d17b5">parse</a> (const char *buf, size_t len, bool realloc_if_needed=true) noexcept</td></tr>
<tr class="memdesc:aedf903ec97071a5364a89068377d17b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a JSON document and return a temporary reference to it.  <a href="classsimdjson_1_1dom_1_1parser.html#aedf903ec97071a5364a89068377d17b5">More...</a><br /></td></tr>
<tr class="separator:aedf903ec97071a5364a89068377d17b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a90db2221208b4dce2d261a421a9b"><td class="memItemLeft" align="right" valign="top">really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a889a90db2221208b4dce2d261a421a9b">parse</a> (const std::string &amp;s) noexcept</td></tr>
<tr class="memdesc:a889a90db2221208b4dce2d261a421a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a JSON document and return a temporary reference to it.  <a href="classsimdjson_1_1dom_1_1parser.html#a889a90db2221208b4dce2d261a421a9b">More...</a><br /></td></tr>
<tr class="separator:a889a90db2221208b4dce2d261a421a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7d0b480d1ad771c024b0f16fe326d1"><td class="memItemLeft" align="right" valign="top">really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#aed7d0b480d1ad771c024b0f16fe326d1">parse</a> (const <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;s) noexcept</td></tr>
<tr class="memdesc:aed7d0b480d1ad771c024b0f16fe326d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a JSON document and return a temporary reference to it.  <a href="classsimdjson_1_1dom_1_1parser.html#aed7d0b480d1ad771c024b0f16fe326d1">More...</a><br /></td></tr>
<tr class="separator:aed7d0b480d1ad771c024b0f16fe326d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273fb071d9837c77aff4b11c26275b21"><td class="memItemLeft" align="right" valign="top"><a id="a273fb071d9837c77aff4b11c26275b21"></a>
really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (const char *buf) noexcept=delete</td></tr>
<tr class="separator:a273fb071d9837c77aff4b11c26275b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b51b6f04a089c55e591c375d4f87e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6b51b6f04a089c55e591c375d4f87e3d">parse_many</a> (const uint8_t *buf, size_t len, size_t batch_size=DEFAULT_BATCH_SIZE) noexcept</td></tr>
<tr class="memdesc:a6b51b6f04a089c55e591c375d4f87e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a buffer containing many JSON documents.  <a href="classsimdjson_1_1dom_1_1parser.html#a6b51b6f04a089c55e591c375d4f87e3d">More...</a><br /></td></tr>
<tr class="separator:a6b51b6f04a089c55e591c375d4f87e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebbf66a379a9e56e4f3f9e99cf4f90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a5ebbf66a379a9e56e4f3f9e99cf4f90e">parse_many</a> (const char *buf, size_t len, size_t batch_size=DEFAULT_BATCH_SIZE) noexcept</td></tr>
<tr class="memdesc:a5ebbf66a379a9e56e4f3f9e99cf4f90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a buffer containing many JSON documents.  <a href="classsimdjson_1_1dom_1_1parser.html#a5ebbf66a379a9e56e4f3f9e99cf4f90e">More...</a><br /></td></tr>
<tr class="separator:a5ebbf66a379a9e56e4f3f9e99cf4f90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066cdaa4a10cf0b5e123f5e0ff657f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a066cdaa4a10cf0b5e123f5e0ff657f13">parse_many</a> (const std::string &amp;s, size_t batch_size=DEFAULT_BATCH_SIZE) noexcept</td></tr>
<tr class="memdesc:a066cdaa4a10cf0b5e123f5e0ff657f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a buffer containing many JSON documents.  <a href="classsimdjson_1_1dom_1_1parser.html#a066cdaa4a10cf0b5e123f5e0ff657f13">More...</a><br /></td></tr>
<tr class="separator:a066cdaa4a10cf0b5e123f5e0ff657f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01917d525b3baf77936bdd050e9e87d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a01917d525b3baf77936bdd050e9e87d9">parse_many</a> (const <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;s, size_t batch_size=DEFAULT_BATCH_SIZE) noexcept</td></tr>
<tr class="memdesc:a01917d525b3baf77936bdd050e9e87d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a buffer containing many JSON documents.  <a href="classsimdjson_1_1dom_1_1parser.html#a01917d525b3baf77936bdd050e9e87d9">More...</a><br /></td></tr>
<tr class="separator:a01917d525b3baf77936bdd050e9e87d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51db2d618fb7cb2c0168b316068d17"><td class="memItemLeft" align="right" valign="top"><a id="a8e51db2d618fb7cb2c0168b316068d17"></a>
really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_many</b> (const char *buf, size_t batch_size=DEFAULT_BATCH_SIZE) noexcept=delete</td></tr>
<tr class="separator:a8e51db2d618fb7cb2c0168b316068d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b68d9202cd9aa595c2c505e09deb2b2"><td class="memItemLeft" align="right" valign="top">really_inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6b68d9202cd9aa595c2c505e09deb2b2">max_capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a6b68d9202cd9aa595c2c505e09deb2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest document this parser can automatically support.  <a href="classsimdjson_1_1dom_1_1parser.html#a6b68d9202cd9aa595c2c505e09deb2b2">More...</a><br /></td></tr>
<tr class="separator:a6b68d9202cd9aa595c2c505e09deb2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eaaa274ecdabb4342223da9e6bd8a7"><td class="memItemLeft" align="right" valign="top">really_inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a02eaaa274ecdabb4342223da9e6bd8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest document this parser can support without reallocating.  <a href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">More...</a><br /></td></tr>
<tr class="separator:a02eaaa274ecdabb4342223da9e6bd8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b970821b8ecb98a0222a9fa4eb57a"><td class="memItemLeft" align="right" valign="top">really_inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a> () const noexcept</td></tr>
<tr class="memdesc:a6a0b970821b8ecb98a0222a9fa4eb57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum level of nested object and arrays supported by this parser.  <a href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">More...</a><br /></td></tr>
<tr class="separator:a6a0b970821b8ecb98a0222a9fa4eb57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc6d25fb25b52dcafc32c3855ffeb98"><td class="memItemLeft" align="right" valign="top">really_inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#acbc6d25fb25b52dcafc32c3855ffeb98">set_max_capacity</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6b68d9202cd9aa595c2c505e09deb2b2">max_capacity</a>) noexcept</td></tr>
<tr class="memdesc:acbc6d25fb25b52dcafc32c3855ffeb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set max_capacity.  <a href="classsimdjson_1_1dom_1_1parser.html#acbc6d25fb25b52dcafc32c3855ffeb98">More...</a><br /></td></tr>
<tr class="separator:acbc6d25fb25b52dcafc32c3855ffeb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddd326a78be00a44bdad848047f3314"><td class="memItemLeft" align="right" valign="top">WARN_UNUSED error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a9ddd326a78be00a44bdad848047f3314">set_capacity</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a>) noexcept</td></tr>
<tr class="memdesc:a9ddd326a78be00a44bdad848047f3314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set capacity.  <a href="classsimdjson_1_1dom_1_1parser.html#a9ddd326a78be00a44bdad848047f3314">More...</a><br /></td></tr>
<tr class="separator:a9ddd326a78be00a44bdad848047f3314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70108bb5f435b61a6798b33030d4acd"><td class="memItemLeft" align="right" valign="top">WARN_UNUSED error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#ae70108bb5f435b61a6798b33030d4acd">set_max_depth</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>) noexcept</td></tr>
<tr class="memdesc:ae70108bb5f435b61a6798b33030d4acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum level of nested object and arrays supported by this parser.  <a href="classsimdjson_1_1dom_1_1parser.html#ae70108bb5f435b61a6798b33030d4acd">More...</a><br /></td></tr>
<tr class="separator:ae70108bb5f435b61a6798b33030d4acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03b08a0d6e5399bb37561c9feacaab4"><td class="memItemLeft" align="right" valign="top">WARN_UNUSED bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#af03b08a0d6e5399bb37561c9feacaab4">allocate_capacity</a> (size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a>, size_t <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>=DEFAULT_MAX_DEPTH) noexcept</td></tr>
<tr class="memdesc:af03b08a0d6e5399bb37561c9feacaab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure this parser has enough memory to process JSON documents up to <code>capacity</code> bytes in length and <code>max_depth</code> depth.  <a href="classsimdjson_1_1dom_1_1parser.html#af03b08a0d6e5399bb37561c9feacaab4">More...</a><br /></td></tr>
<tr class="separator:af03b08a0d6e5399bb37561c9feacaab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebf92d4ba356ec797d55c035bac2f20"><td class="memItemLeft" align="right" valign="top"><a id="acebf92d4ba356ec797d55c035bac2f20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid</b> () const noexcept</td></tr>
<tr class="separator:acebf92d4ba356ec797d55c035bac2f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af650d8537de34b839ae52b3283d10233"><td class="memItemLeft" align="right" valign="top"><a id="af650d8537de34b839ae52b3283d10233"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_error_code</b> () const noexcept</td></tr>
<tr class="separator:af650d8537de34b839ae52b3283d10233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb20b83d4d709a1714491afb20ddb78"><td class="memItemLeft" align="right" valign="top"><a id="a7bb20b83d4d709a1714491afb20ddb78"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_error_message</b> () const noexcept</td></tr>
<tr class="separator:a7bb20b83d4d709a1714491afb20ddb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57292c5a5c5d6fe896b5a9de7c041d0d"><td class="memItemLeft" align="right" valign="top"><a id="a57292c5a5c5d6fe896b5a9de7c041d0d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>print_json</b> (std::ostream &amp;os) const noexcept</td></tr>
<tr class="separator:a57292c5a5c5d6fe896b5a9de7c041d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a94a3ba5e3212b8d4868f7370fdda8161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a94a3ba5e3212b8d4868f7370fdda8161">valid</a> {false}</td></tr>
<tr class="separator:a94a3ba5e3212b8d4868f7370fdda8161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db61495e22e7ab1223ef280a3a76986"><td class="memItemLeft" align="right" valign="top">error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a0db61495e22e7ab1223ef280a3a76986">error</a> {UNINITIALIZED}</td></tr>
<tr class="separator:a0db61495e22e7ab1223ef280a3a76986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3894a5d505faebb91164b1aaa1fc36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdjson_1_1dom_1_1parser.html#a7c3894a5d505faebb91164b1aaa1fc36">doc</a></td></tr>
<tr class="separator:a7c3894a5d505faebb91164b1aaa1fc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A persistent document parser. </p>
<p>The parser is designed to be reused, holding the internal buffers necessary to do parsing, as well as memory for a single document. The parsed document is overwritten on each parse.</p>
<p>This class cannot be copied, only moved, to avoid unintended allocations.</p>
<dl class="section note"><dt>Note</dt><dd>This is not thread safe: one parser cannot produce two documents at the same time! </dd></dl>

<p class="definition">Definition at line <a class="el" href="document_8h_source.html#l00584">584</a> of file <a class="el" href="document_8h_source.html">document.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a19a5c0e2e4383019b496f950eb783c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a5c0e2e4383019b496f950eb783c3b">&#9670;&nbsp;</a></span>InvalidJSON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a19a5c0e2e4383019b496f950eb783c3b">simdjson::dom::parser::InvalidJSON</a> =  <a class="el" href="structsimdjson_1_1simdjson__error.html">simdjson_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="structsimdjson_1_1simdjson__error.html" title="Exception thrown when an exception-supporting simdjson method is called.">simdjson_error</a> instead </dd></dl>

<p class="definition">Definition at line <a class="el" href="document_8h_source.html#l01155">1155</a> of file <a class="el" href="document_8h_source.html">document.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a27f96e41ca560e88b015e07490b4ab52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f96e41ca560e88b015e07490b4ab52">&#9670;&nbsp;</a></span>parser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline simdjson::dom::parser::parser </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_capacity</em> = <code>SIMDJSON_MAXSIZE_BYTES</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>DEFAULT_MAX_DEPTH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a JSON parser. </p>
<p>The new parser will have zero capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_capacity</td><td>The maximum document length the parser can automatically handle. The parser will allocate more capacity on an as needed basis (when it sees documents too big to handle) up to this amount. The parser still starts with zero capacity no matter what this number is: to allocate an initial capacity, call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a9ddd326a78be00a44bdad848047f3314" title="Set capacity.">set_capacity()</a> after constructing the parser. Defaults to SIMDJSON_MAXSIZE_BYTES (the largest single document simdjson can process). </td></tr>
    <tr><td class="paramname">max_depth</td><td>The maximum depth&ndash;number of nested objects and arrays&ndash;this parser can handle. This will not be allocated until <a class="el" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead" title="Parse a JSON document and return a temporary reference to it.">parse()</a> is called for the first time. Defaults to DEFAULT_MAX_DEPTH. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00304">304</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  : _max_capacity{<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6b68d9202cd9aa595c2c505e09deb2b2">max_capacity</a>}, _max_depth{<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>}, loaded_bytes(<span class="keyword">nullptr</span>, &amp;aligned_free_char) {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4285c54961cf32b0815527d662e2b7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4285c54961cf32b0815527d662e2b7a1">&#9670;&nbsp;</a></span>parser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson::dom::parser::parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take another parser's buffers and state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The parser to take. Its capacity is zeroed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af03b08a0d6e5399bb37561c9feacaab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03b08a0d6e5399bb37561c9feacaab4">&#9670;&nbsp;</a></span>allocate_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WARN_UNUSED bool simdjson::dom::parser::allocate_capacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>DEFAULT_MAX_DEPTH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure this parser has enough memory to process JSON documents up to <code>capacity</code> bytes in length and <code>max_depth</code> depth. </p>
<p>Equivalent to calling <a class="el" href="classsimdjson_1_1dom_1_1parser.html#a9ddd326a78be00a44bdad848047f3314" title="Set capacity.">set_capacity()</a> and <a class="el" href="classsimdjson_1_1dom_1_1parser.html#ae70108bb5f435b61a6798b33030d4acd" title="Set the maximum level of nested object and arrays supported by this parser.">set_max_depth()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The new capacity. </td></tr>
    <tr><td class="paramname">max_depth</td><td>The new max_depth. Defaults to DEFAULT_MAX_DEPTH. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if allocation failed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00494">494</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  <span class="keywordflow">return</span> !<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a9ddd326a78be00a44bdad848047f3314">set_capacity</a>(<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a>) &amp;&amp; !<a class="code" href="classsimdjson_1_1dom_1_1parser.html#ae70108bb5f435b61a6798b33030d4acd">set_max_depth</a>(<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>);</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a02eaaa274ecdabb4342223da9e6bd8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eaaa274ecdabb4342223da9e6bd8a7">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline size_t simdjson::dom::parser::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The largest document this parser can support without reallocating. </p>
<dl class="section return"><dt>Returns</dt><dd>Current capacity, in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00414">414</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                                                     {</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="keywordflow">return</span> _capacity;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af5160192e89c4fa75d92819cde9750a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5160192e89c4fa75d92819cde9750a9">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a JSON document from a file and return a reference to it. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; const element doc = <a class="el" href="classsimdjson_1_1dom_1_1parser.html#af5160192e89c4fa75d92819cde9750a9" title="Load a JSON document from a file and return a reference to it.">parser.load</a>("jsonexamples/twitter.json");</p>
<h3><a class="anchor" id="autotoc_md0"></a>
IMPORTANT: Document Lifetime</h3>
<p>The JSON document still lives in the parser: this is the most efficient way to parse JSON documents because it reuses the same buffers, but you <em>must</em> use the document before you destroy the parser or call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead" title="Parse a JSON document and return a temporary reference to it.">parse()</a> again.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than the file length, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The document, or an error:<ul>
<li>IO_ERROR if there was an error opening or reading the file.</li>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00356">356</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                                                                           {</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  <span class="keyword">auto</span> [len, code] = read_file(path);</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  <span class="keywordflow">if</span> (code) { <span class="keywordflow">return</span> code; }</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead">parse</a>(loaded_bytes.get(), len, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a55b8b3e4587e5200ce45e96cf474eed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b8b3e4587e5200ce45e96cf474eed3">&#9670;&nbsp;</a></span>load_many()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> simdjson::dom::parser::load_many </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a file containing many JSON documents. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (const element doc : parser.parse_many(path)) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Format</h3>
<p>The file must contain a series of one or more JSON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)</p>
<p>documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.e. documents that are not arrays or objects) MUST be separated with whitespace.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Error Handling</h3>
<p>All errors are returned during iteration: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.</p>
<p>As with all other simdjson methods, non-exception error handling is readily available through the same interface, requiring you to check the error before using the document:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (auto [doc, error] : parser.load_many(path)) { if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Threads</h3>
<p>When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the hood to do some lookahead.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The concatenated JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes. </td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use. MUST be larger than the largest document. The sweet spot is cache-related: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream. If there is an error, it will be returned during iteration. An empty input will yield 0 documents rather than an EMPTY error. Errors:<ul>
<li>IO_ERROR if there was an error opening or reading the file.</li>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</li>
<li>other json errors if parsing fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00363">363</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                                                                                          {</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <span class="keyword">auto</span> [len, code] = read_file(path);</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  <span class="keywordflow">return</span> document_stream(*<span class="keyword">this</span>, (<span class="keyword">const</span> uint8_t*)loaded_bytes.get(), len, batch_size, code);</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b68d9202cd9aa595c2c505e09deb2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b68d9202cd9aa595c2c505e09deb2b2">&#9670;&nbsp;</a></span>max_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline size_t simdjson::dom::parser::max_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The largest document this parser can automatically support. </p>
<p>The parser may reallocate internal buffers as needed up to this amount.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum capacity, in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00417">417</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                                                         {</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  <span class="keywordflow">return</span> _max_capacity;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a0b970821b8ecb98a0222a9fa4eb57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0b970821b8ecb98a0222a9fa4eb57a">&#9670;&nbsp;</a></span>max_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline size_t simdjson::dom::parser::max_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum level of nested object and arrays supported by this parser. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum depth, in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00420">420</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                                                      {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  <span class="keywordflow">return</span> _max_depth;</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab85e053daae3f5197f7c6168b505e2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e053daae3f5197f7c6168b505e2c4">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a>&amp; simdjson::dom::parser::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimdjson_1_1dom_1_1parser.html">parser</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take another parser's buffers and state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The parser to take. Its capacity is zeroed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedf903ec97071a5364a89068377d17b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf903ec97071a5364a89068377d17b5">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>realloc_if_needed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a JSON document and return a temporary reference to it. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; const element doc = parser.parse(buf, len);</p>
<h3><a class="anchor" id="autotoc_md9"></a>
IMPORTANT: Document Lifetime</h3>
<p>The JSON document still lives in the parser: this is the most efficient way to parse JSON documents because it reuses the same buffers, but you <em>must</em> use the document before you destroy the parser or call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead" title="Parse a JSON document and return a temporary reference to it.">parse()</a> again.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.</p>
<p>If realloc_if_needed is true, it is assumed that the buffer does <em>not</em> have enough padding, and it is copied into an enlarged temporary buffer before parsing.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than len, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes, unless realloc_if_needed is true. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the JSON. </td></tr>
    <tr><td class="paramname">realloc_if_needed</td><td>Whether to reallocate and enlarge the JSON buffer to add padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The document, or an error:<ul>
<li>MEMALLOC if realloc_if_needed is true or the parser does not have enough capacity, and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00391">391</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                                                                                                                 {</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead">parse</a>((<span class="keyword">const</span> uint8_t *)buf, len, realloc_if_needed);</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed7d0b480d1ad771c024b0f16fe326d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7d0b480d1ad771c024b0f16fe326d1">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a JSON document and return a temporary reference to it. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; const element doc = parser.parse(s);</p>
<h3><a class="anchor" id="autotoc_md15"></a>
IMPORTANT: Document Lifetime</h3>
<p>The JSON document still lives in the parser: this is the most efficient way to parse JSON documents because it reuses the same buffers, but you <em>must</em> use the document before you destroy the parser or call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead" title="Parse a JSON document and return a temporary reference to it.">parse()</a> again.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The JSON to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The document, or an error:<ul>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00397">397</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead">parse</a>(s.data(), s.length(), <span class="keyword">false</span>);</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a889a90db2221208b4dce2d261a421a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889a90db2221208b4dce2d261a421a9b">&#9670;&nbsp;</a></span>parse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a JSON document and return a temporary reference to it. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; const element doc = parser.parse(s);</p>
<h3><a class="anchor" id="autotoc_md12"></a>
IMPORTANT: Document Lifetime</h3>
<p>The JSON document still lives in the parser: this is the most efficient way to parse JSON documents because it reuses the same buffers, but you <em>must</em> use the document before you destroy the parser or call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead" title="Parse a JSON document and return a temporary reference to it.">parse()</a> again.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.</p>
<p>If s.capacity() is less than SIMDJSON_PADDING, the string will be copied into an enlarged temporary buffer before parsing.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than len, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes, or a new string will be created with the extra padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The document, or an error:<ul>
<li>MEMALLOC if the string does not have enough padding or the parser does not have enough capacity, and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00394">394</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                                                                                {</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead">parse</a>(s.data(), s.length(), s.capacity() - s.length() &lt; SIMDJSON_PADDING);</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb4f62b70475ec8067196ac53dfdbead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4f62b70475ec8067196ac53dfdbead">&#9670;&nbsp;</a></span>parse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1dom_1_1element.html">element</a> &gt; simdjson::dom::parser::parse </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>realloc_if_needed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a JSON document and return a temporary reference to it. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; element doc = parser.parse(buf, len);</p>
<h3><a class="anchor" id="autotoc_md6"></a>
IMPORTANT: Document Lifetime</h3>
<p>The JSON document still lives in the parser: this is the most efficient way to parse JSON documents because it reuses the same buffers, but you <em>must</em> use the document before you destroy the parser or call <a class="el" href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead" title="Parse a JSON document and return a temporary reference to it.">parse()</a> again.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.</p>
<p>If realloc_if_needed is true, it is assumed that the buffer does <em>not</em> have enough padding, and it is copied into an enlarged temporary buffer before parsing.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than len, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes, unless realloc_if_needed is true. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the JSON. </td></tr>
    <tr><td class="paramname">realloc_if_needed</td><td>Whether to reallocate and enlarge the JSON buffer to add padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The document, or an error:<ul>
<li>MEMALLOC if realloc_if_needed is true or the parser does not have enough capacity, and memory allocation fails.</li>
<li>CAPACITY if the parser does not have enough capacity and len &gt; max_capacity.</li>
<li>other json errors if parsing fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00368">368</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                                                                                             {</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  error_code code = ensure_capacity(len);</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <span class="keywordflow">if</span> (code) { <span class="keywordflow">return</span> code; }</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160; </div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="keywordflow">if</span> (realloc_if_needed) {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keyword">const</span> uint8_t *tmp_buf = buf;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    buf = (uint8_t *)internal::allocate_padded_buffer(len);</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="keywordflow">if</span> (buf == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      <span class="keywordflow">return</span> MEMALLOC;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    memcpy((<span class="keywordtype">void</span> *)buf, tmp_buf, len);</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  }</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160; </div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  code = simdjson::active_implementation-&gt;parse(buf, len, *<span class="keyword">this</span>);</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keywordflow">if</span> (realloc_if_needed) {</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    aligned_free((<span class="keywordtype">void</span> *)buf); <span class="comment">// must free before we exit</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;  }</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  <span class="keywordflow">if</span> (code) { <span class="keywordflow">return</span> code; }</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160; </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  <span class="comment">// We&#39;re indicating validity via the simdjson_result&lt;element&gt;, so set the parse state back to invalid</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a94a3ba5e3212b8d4868f7370fdda8161">valid</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a0db61495e22e7ab1223ef280a3a76986">error</a> = UNINITIALIZED;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a7c3894a5d505faebb91164b1aaa1fc36">doc</a>.<a class="code" href="classsimdjson_1_1dom_1_1document.html#ae19dced0eee5f63b9d1591ef51dcda4e">root</a>();</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ebbf66a379a9e56e4f3f9e99cf4f90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebbf66a379a9e56e4f3f9e99cf4f90e">&#9670;&nbsp;</a></span>parse_many() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> simdjson::dom::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a buffer containing many JSON documents. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (const element doc : parser.parse_many(buf, len)) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Format</h3>
<p>The buffer must contain a series of one or more JSON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)</p>
<p>documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.e. documents that are not arrays or objects) MUST be separated with whitespace.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Error Handling</h3>
<p>All errors are returned during iteration: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.</p>
<p>As with all other simdjson methods, non-exception error handling is readily available through the same interface, requiring you to check the error before using the document:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (auto [doc, error] : parser.parse_many(buf, len)) { if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md24"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
Threads</h3>
<p>When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the hood to do some lookahead.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The concatenated JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the concatenated JSON. </td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use. MUST be larger than the largest document. The sweet spot is cache-related: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream. If there is an error, it will be returned during iteration. An empty input will yield 0 documents rather than an EMPTY error. Errors:<ul>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails</li>
<li>CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</li>
<li>other json errors if parsing fails </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00404">404</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                                                                                                 {</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6b51b6f04a089c55e591c375d4f87e3d">parse_many</a>((<span class="keyword">const</span> uint8_t *)buf, len, batch_size);</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a01917d525b3baf77936bdd050e9e87d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01917d525b3baf77936bdd050e9e87d9">&#9670;&nbsp;</a></span>parse_many() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> simdjson::dom::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsimdjson_1_1padded__string.html">padded_string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a buffer containing many JSON documents. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (const element doc : parser.parse_many(buf, len)) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md32"></a>
Format</h3>
<p>The buffer must contain a series of one or more JSON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)</p>
<p>documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.e. documents that are not arrays or objects) MUST be separated with whitespace.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Error Handling</h3>
<p>All errors are returned during iteration: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.</p>
<p>As with all other simdjson methods, non-exception error handling is readily available through the same interface, requiring you to check the error before using the document:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (auto [doc, error] : parser.parse_many(buf, len)) { if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md34"></a>
Threads</h3>
<p>When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the hood to do some lookahead.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The concatenated JSON to parse. </td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use. MUST be larger than the largest document. The sweet spot is cache-related: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream. If there is an error, it will be returned during iteration. An empty input will yield 0 documents rather than an EMPTY error. Errors:<ul>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails</li>
<li>CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</li>
<li>other json errors if parsing fails </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00410">410</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6b51b6f04a089c55e591c375d4f87e3d">parse_many</a>(s.data(), s.length(), batch_size);</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a066cdaa4a10cf0b5e123f5e0ff657f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066cdaa4a10cf0b5e123f5e0ff657f13">&#9670;&nbsp;</a></span>parse_many() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> simdjson::dom::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a buffer containing many JSON documents. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (const element doc : parser.parse_many(buf, len)) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Format</h3>
<p>The buffer must contain a series of one or more JSON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)</p>
<p>documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.e. documents that are not arrays or objects) MUST be separated with whitespace.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
Error Handling</h3>
<p>All errors are returned during iteration: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.</p>
<p>As with all other simdjson methods, non-exception error handling is readily available through the same interface, requiring you to check the error before using the document:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (auto [doc, error] : parser.parse_many(buf, len)) { if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md29"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Threads</h3>
<p>When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the hood to do some lookahead.</p>
<h3><a class="anchor" id="autotoc_md31"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The concatenated JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes. </td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use. MUST be larger than the largest document. The sweet spot is cache-related: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream. If there is an error, it will be returned during iteration. An empty input will yield 0 documents rather than an EMPTY error. Errors:<ul>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails</li>
<li>CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</li>
<li>other json errors if parsing fails </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00407">407</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                                                                                        {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6b51b6f04a089c55e591c375d4f87e3d">parse_many</a>(s.data(), s.length(), batch_size);</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b51b6f04a089c55e591c375d4f87e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b51b6f04a089c55e591c375d4f87e3d">&#9670;&nbsp;</a></span>parse_many() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1document__stream.html">document_stream</a> simdjson::dom::parser::parse_many </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>DEFAULT_BATCH_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a buffer containing many JSON documents. </p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (const element doc : parser.parse_many(buf, len)) { cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Format</h3>
<p>The buffer must contain a series of one or more JSON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)</p>
<p>documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.e. documents that are not arrays or objects) MUST be separated with whitespace.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Error Handling</h3>
<p>All errors are returned during iteration: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.</p>
<p>As with all other simdjson methods, non-exception error handling is readily available through the same interface, requiring you to check the error before using the document:</p>
<p><a class="el" href="classsimdjson_1_1dom_1_1parser.html" title="A persistent document parser.">dom::parser</a> parser; for (auto [doc, error] : parser.parse_many(buf, len)) { if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); } cout &lt;&lt; std::string(doc["title"]) &lt;&lt; endl; }</p>
<h3><a class="anchor" id="autotoc_md19"></a>
REQUIRED: Buffer Padding</h3>
<p>The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Threads</h3>
<p>When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the hood to do some lookahead.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
Parser Capacity</h3>
<p>If the parser's current capacity is less than batch_size, it will allocate enough capacity to handle it (up to max_capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The concatenated JSON to parse. Must have at least len + SIMDJSON_PADDING allocated bytes. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the concatenated JSON. </td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size to use. MUST be larger than the largest document. The sweet spot is cache-related: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream. If there is an error, it will be returned during iteration. An empty input will yield 0 documents rather than an EMPTY error. Errors:<ul>
<li>MEMALLOC if the parser does not have enough capacity and memory allocation fails</li>
<li>CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</li>
<li>other json errors if parsing fails. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00401">401</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                                                                                                    {</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  <span class="keywordflow">return</span> document_stream(*<span class="keyword">this</span>, buf, len, batch_size);</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ddd326a78be00a44bdad848047f3314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddd326a78be00a44bdad848047f3314">&#9670;&nbsp;</a></span>set_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WARN_UNUSED error_code simdjson::dom::parser::set_capacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set capacity. </p>
<p>This is the largest document this parser can support without reallocating.</p>
<p>This will allocate or deallocate as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The new capacity, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MEMALLOC if unsuccessful, SUCCESS otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00425">425</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                                                               {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  <span class="keywordflow">if</span> (_capacity == <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a>) {</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  }</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160; </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  <span class="comment">// Set capacity to 0 until we finish, in case there&#39;s an error</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  _capacity = 0;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160; </div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="comment">// Reallocate the document</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  error_code err = <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a7c3894a5d505faebb91164b1aaa1fc36">doc</a>.set_capacity(<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a>);</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;  <span class="keywordflow">if</span> (err) { <span class="keywordflow">return</span> err; }</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; </div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="comment">// Don&#39;t allocate 0 bytes, just return.</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a> == 0) {</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    structural_indexes.reset();</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;  }</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160; </div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;  <span class="comment">// Initialize stage 1 output</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;  uint32_t max_structures = ROUNDUP_N(<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a>, 64) + 2 + 7;</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;  structural_indexes.reset( <span class="keyword">new</span> (std::nothrow) uint32_t[max_structures] ); <span class="comment">// TODO realloc</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  <span class="keywordflow">if</span> (!structural_indexes) {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="keywordflow">return</span> MEMALLOC;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  }</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160; </div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  _capacity = <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">capacity</a>;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acbc6d25fb25b52dcafc32c3855ffeb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc6d25fb25b52dcafc32c3855ffeb98">&#9670;&nbsp;</a></span>set_max_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">really_inline void simdjson::dom::parser::set_max_capacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set max_capacity. </p>
<p>This is the largest document this parser can automatically support.</p>
<p>The parser may reallocate internal buffers as needed up to this amount.</p>
<p>This call will not allocate or deallocate, even if capacity is currently above max_capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_capacity</td><td>The new maximum capacity, in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00460">460</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                                                                        {</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  _max_capacity = <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6b68d9202cd9aa595c2c505e09deb2b2">max_capacity</a>;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae70108bb5f435b61a6798b33030d4acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70108bb5f435b61a6798b33030d4acd">&#9670;&nbsp;</a></span>set_max_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WARN_UNUSED error_code simdjson::dom::parser::set_max_depth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum level of nested object and arrays supported by this parser. </p>
<p>This will allocate or deallocate as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>The new maximum depth, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MEMALLOC if unsuccessful, SUCCESS otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="inline_2document_8h_source.html#l00464">464</a> of file <a class="el" href="inline_2document_8h_source.html">document.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                                                                             {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a> == _max_depth &amp;&amp; ret_address) { <span class="keywordflow">return</span> SUCCESS; }</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160; </div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  _max_depth = 0;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160; </div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a> == 0) {</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    ret_address.reset();</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    containing_scope_offset.reset();</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  }</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160; </div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="comment">// Initialize stage 2 state</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  containing_scope_offset.reset(<span class="keyword">new</span> (std::nothrow) uint32_t[<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>]); <span class="comment">// TODO realloc</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="preprocessor">#ifdef SIMDJSON_USE_COMPUTED_GOTO</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  ret_address.reset(<span class="keyword">new</span> (std::nothrow) <span class="keywordtype">void</span> *[<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>]);</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  ret_address.reset(<span class="keyword">new</span> (std::nothrow) <span class="keywordtype">char</span>[<a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>]);</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160; </div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  <span class="keywordflow">if</span> (!ret_address || !containing_scope_offset) {</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="comment">// Could not allocate memory</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keywordflow">return</span> MEMALLOC;</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160; </div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  _max_depth = <a class="code" href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">max_depth</a>;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7c3894a5d505faebb91164b1aaa1fc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3894a5d505faebb91164b1aaa1fc36">&#9670;&nbsp;</a></span>doc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimdjson_1_1dom_1_1document.html">document</a> simdjson::dom::parser::doc</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use <code>parser.parse(...).doc</code> instead </dd></dl>

<p class="definition">Definition at line <a class="el" href="document_8h_source.html#l01184">1184</a> of file <a class="el" href="document_8h_source.html">document.h</a>.</p>

</div>
</div>
<a id="a0db61495e22e7ab1223ef280a3a76986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db61495e22e7ab1223ef280a3a76986">&#9670;&nbsp;</a></span>error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">error_code simdjson::dom::parser::error {UNINITIALIZED}</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use <code>parser.parse(...).error</code> instead </dd></dl>

<p class="definition">Definition at line <a class="el" href="document_8h_source.html#l01181">1181</a> of file <a class="el" href="document_8h_source.html">document.h</a>.</p>

</div>
</div>
<a id="a94a3ba5e3212b8d4868f7370fdda8161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a3ba5e3212b8d4868f7370fdda8161">&#9670;&nbsp;</a></span>valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool simdjson::dom::parser::valid {false}</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <code>if (parser.parse(...).error)</code> instead </dd></dl>

<p class="definition">Definition at line <a class="el" href="document_8h_source.html#l01179">1179</a> of file <a class="el" href="document_8h_source.html">document.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/simdjson/<a class="el" href="document_8h_source.html">document.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a6b68d9202cd9aa595c2c505e09deb2b2"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a6b68d9202cd9aa595c2c505e09deb2b2">simdjson::dom::parser::max_capacity</a></div><div class="ttdeci">really_inline size_t max_capacity() const noexcept</div><div class="ttdoc">The largest document this parser can automatically support.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00417">document.h:417</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a02eaaa274ecdabb4342223da9e6bd8a7"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a02eaaa274ecdabb4342223da9e6bd8a7">simdjson::dom::parser::capacity</a></div><div class="ttdeci">really_inline size_t capacity() const noexcept</div><div class="ttdoc">The largest document this parser can support without reallocating.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00414">document.h:414</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_adb4f62b70475ec8067196ac53dfdbead"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#adb4f62b70475ec8067196ac53dfdbead">simdjson::dom::parser::parse</a></div><div class="ttdeci">simdjson_result&lt; element &gt; parse(const uint8_t *buf, size_t len, bool realloc_if_needed=true) noexcept</div><div class="ttdoc">Parse a JSON document and return a temporary reference to it.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00368">document.h:368</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_ae70108bb5f435b61a6798b33030d4acd"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#ae70108bb5f435b61a6798b33030d4acd">simdjson::dom::parser::set_max_depth</a></div><div class="ttdeci">WARN_UNUSED error_code set_max_depth(size_t max_depth) noexcept</div><div class="ttdoc">Set the maximum level of nested object and arrays supported by this parser.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00464">document.h:464</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a6b51b6f04a089c55e591c375d4f87e3d"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a6b51b6f04a089c55e591c375d4f87e3d">simdjson::dom::parser::parse_many</a></div><div class="ttdeci">document_stream parse_many(const uint8_t *buf, size_t len, size_t batch_size=DEFAULT_BATCH_SIZE) noexcept</div><div class="ttdoc">Parse a buffer containing many JSON documents.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00401">document.h:401</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1document_html_ae19dced0eee5f63b9d1591ef51dcda4e"><div class="ttname"><a href="classsimdjson_1_1dom_1_1document.html#ae19dced0eee5f63b9d1591ef51dcda4e">simdjson::dom::document::root</a></div><div class="ttdeci">element root() const noexcept</div><div class="ttdoc">Get the root element of this document as a JSON array.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00178">document.h:178</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a7c3894a5d505faebb91164b1aaa1fc36"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a7c3894a5d505faebb91164b1aaa1fc36">simdjson::dom::parser::doc</a></div><div class="ttdeci">document doc</div><div class="ttdef"><b>Definition:</b> <a href="document_8h_source.html#l01184">document.h:1184</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a9ddd326a78be00a44bdad848047f3314"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a9ddd326a78be00a44bdad848047f3314">simdjson::dom::parser::set_capacity</a></div><div class="ttdeci">WARN_UNUSED error_code set_capacity(size_t capacity) noexcept</div><div class="ttdoc">Set capacity.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00425">document.h:425</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a6a0b970821b8ecb98a0222a9fa4eb57a"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a6a0b970821b8ecb98a0222a9fa4eb57a">simdjson::dom::parser::max_depth</a></div><div class="ttdeci">really_inline size_t max_depth() const noexcept</div><div class="ttdoc">The maximum level of nested object and arrays supported by this parser.</div><div class="ttdef"><b>Definition:</b> <a href="inline_2document_8h_source.html#l00420">document.h:420</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a94a3ba5e3212b8d4868f7370fdda8161"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a94a3ba5e3212b8d4868f7370fdda8161">simdjson::dom::parser::valid</a></div><div class="ttdeci">bool valid</div><div class="ttdef"><b>Definition:</b> <a href="document_8h_source.html#l01179">document.h:1179</a></div></div>
<div class="ttc" id="aclasssimdjson_1_1dom_1_1parser_html_a0db61495e22e7ab1223ef280a3a76986"><div class="ttname"><a href="classsimdjson_1_1dom_1_1parser.html#a0db61495e22e7ab1223ef280a3a76986">simdjson::dom::parser::error</a></div><div class="ttdeci">error_code error</div><div class="ttdef"><b>Definition:</b> <a href="document_8h_source.html#l01181">document.h:1181</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
