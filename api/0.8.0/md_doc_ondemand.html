<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: On Demand Basics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdjson
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">On Demand Basics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>On Demand is a new, faster simdjson API with all the ease-of-use you are used to. While it provides a familiar DOM interface, under the hood it is different: it is parsing values <em>as you use them.</em> With On Demand, you do not waste time parsing JSON you do not use, and you do not pay the cost of generating an intermediate DOM tree.</p>
<p>We provide an overview of what you need to know to use the simdjson On Demand API, with examples.</p>
<ul>
<li><a href="#including-on-demand">Including ondemand</a></li>
<li><a href="#the-basics-loading-and-parsing-json-documents">The Basics: Loading and Parsing JSON Documents</a></li>
<li><a href="#using-the-parsed-json">Using the Parsed JSON</a></li>
</ul>
<p>The On Demand API supports the same JSON standards and C++ compilers as simdjson's DOM API. Refer to the DOM docs for more information:</p>
<ul>
<li><a href="basics.md##requirements">Requirements</a></li>
<li><a href="#using-simdjson-as-a-cmake-dependency">Using simdjson as a CMake dependency</a></li>
<li><a href="basics.md#error-handling">Error Handling</a><ul>
<li><a href="basics.md#error-handling-example">Error Handling Example</a></li>
<li><a href="basics.md#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a href="basics.md#thread-safety">Thread Safety</a></li>
<li><a href="basics.md#standard-compliance">Standard Compliance</a></li>
<li><a href="basics.md#c11-support-and-string_view">C++11 Support and string_view</a></li>
<li><a href="basics.md#c17-support">C++17 Support</a></li>
<li><a href="basics.md#backwards-compatibility">Backwards Compatibility</a></li>
</ul>
<p>For deeper information about the design and implementation of the simdjson On Demand API, refer to the <a class="el" href="md_doc_ondemand.html">design document</a>.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Including On Demand</h1>
<p>To include simdjson, copy <a href="/singleheader/simdjson.h">simdjson.h</a> and <a href="/singleheader/simdjson.cpp">simdjson.cpp</a> into your project. Then include it in your project with:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line">using namespace simdjson; // optional</div>
</div><!-- fragment --><p>You can generally compile with:</p>
<div class="fragment"><div class="line">c++ -O3 myproject.cpp simdjson.cpp</div>
</div><!-- fragment --><p>Note:</p><ul>
<li>Users on macOS and other platforms where compilers do not provide C++11 compliant by default should request it with the appropriate flag (e.g., <code>c++ -march=native -std=c++17 myproject.cpp simdjson.cpp</code>).</li>
</ul>
<h1><a class="anchor" id="autotoc_md45"></a>
The Basics: Loading and Parsing JSON Documents</h1>
<p>The simdjson library offers a simple DOM tree API, which you can access by creating a <code>ondemand::parser</code> and calling the <code>iterate()</code> method:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = padded_string::load(&quot;twitter.json&quot;);</div>
<div class="line">ondemand::document doc = parser.iterate(json); // load and parse a file</div>
</div><!-- fragment --><p>Or by creating a padded string (for efficiency reasons, simdjson requires a string with SIMDJSON_PADDING bytes at the end) and calling <code>iterate()</code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = &quot;[1,2,3]&quot;_padded; // The _padded suffix creates a simdjson::padded_string instance</div>
<div class="line">ondemand::document doc = parser.iterate(json); // parse a string</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md46"></a>
Documents Are Iterators</h1>
<p>A <code>document</code> is <em>not</em> a fully-parsed JSON value; rather, it is an <b>iterator</b> over the JSON text. This means that while you iterate an array, or search for a field in an object, it is actually walking through the original JSON text, merrily reading commas and colons and brackets to make sure you get where you are going. This is the key to On Demand's performance: since it's just an iterator, it lets you parse values as you use them. And particularly, it lets you <em>skip</em> values you do not want to use.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Parser, Document and JSON Scope</h2>
<p>Because a document is an iterator over the JSON text, both the JSON text and the parser must remain alive (in scope) while you are using it. Further, a <code>parser</code> may have at most one document open at a time, since it holds allocated memory used for the parsing.</p>
<p>During the <code>iterate</code> call, the original JSON text is never modified&ndash;only read. After you are done with the document, the source (whether file or string) can be safely discarded.</p>
<p>For best performance, a <code>parser</code> instance should be reused over several files: otherwise you will needlessly reallocate memory, an expensive process. It is also possible to avoid entirely memory allocations during parsing when using simdjson. <a class="el" href="md_doc_performance.html">See our performance notes for details</a>.</p>
<h1><a class="anchor" id="autotoc_md48"></a>
Using the Parsed JSON</h1>
<p>Once you have a document, you can navigate it with idiomatic C++ iterators, operators and casts. The following show how to use the JSON when exceptions are enabled, but simdjson has full, idiomatic support for users who avoid exceptions. See <a href="basics.md#error-handling">the simdjson DOM API's error handling documentation</a> for more.</p>
<ul>
<li><b>Extracting Values:</b> You can cast a JSON element to a native type: <code>double(element)</code> or <code>double x = json_element</code>. This works for double, uint64_t, int64_t, bool, ondemand::object and ondemand::array. At this point, the number, string or boolean will be parsed, or the initial <code>[</code> or <code>{</code> will be verified. An exception is thrown if the cast is not possible.</li>
</ul>
<blockquote class="doxtable">
<p>IMPORTANT NOTE: values can only be parsed once. Since documents are <em>iterators</em>, once you have parsed a value (such as by casting to double), you cannot get at it again. </p>
</blockquote>
<ul>
<li><b>Field Access:</b> To get the value of the "foo" field in an object, use <code>object["foo"]</code>. This will scan through the object looking for the field with the matching string.</li>
</ul>
<blockquote class="doxtable">
<p>NOTE: simdjson does <em>not</em> unescape keys when matching. This is not generally a problem for applications with well-defined key names (which generally do not use escapes). If you do need this support, it's best to iterate through the object fields to find the field you are looking for.</p>
<p>By default, field lookup is order-insensitive, so you can look up values in any order. However, we still encourage you to look up fields in the order you expect them in the JSON, as it is still much faster.</p>
<p>If you want to enforce finding fields in order, you can use <code>object.find_field("foo")</code> instead. This will only look forward, and will fail to find fields in the wrong order: for example, this will fail:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = R&quot;(  { &quot;x&quot;: 1, &quot;y&quot;: 2 }  )&quot;_padded;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">double y = doc.find_field(&quot;y&quot;); // The cursor is now after the 2 (at })</div>
<div class="line">double x = doc.find_field(&quot;x&quot;); // This fails, because there are no more fields after &quot;y&quot;</div>
</div><!-- fragment --><p>By contrast, using the default (order-insensitive) lookup succeeds:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = R&quot;(  { &quot;x&quot;: 1, &quot;y&quot;: 2 }  )&quot;_padded;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">double y = doc[&quot;y&quot;]; // The cursor is now after the 2 (at })</div>
<div class="line">double x = doc[&quot;x&quot;]; // Success: [] loops back around to find &quot;x&quot;</div>
</div><!-- fragment --><p></p>
</blockquote>
<ul>
<li><p class="startli"><b>Array Iteration:</b> To iterate through an array, use <code>for (auto value : array) { ... }</code>. This will step through each value in the JSON array.</p>
<p class="startli">If you know the type of the value, you can cast it right there, too! <code>for (double value : array) { ... }</code>.</p>
</li>
<li><b>Object Iteration:</b> You can iterate through an object's fields, as well: <code>for (auto field : object) { ... }</code><ul>
<li><code>field.unescaped_key()</code> will get you the key string.</li>
<li><code>field.value()</code> will get you the value, which you can then use all these other methods on.</li>
</ul>
</li>
<li><b>Array Index:</b> Because it is forward-only, you cannot look up an array element by index. Instead, you will need to iterate through the array and keep an index yourself.</li>
</ul>
<h2><a class="anchor" id="autotoc_md49"></a>
Examples</h2>
<p>The following code illustrates many of the above concepts:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line"> </div>
<div class="line">// Iterating through an array of objects</div>
<div class="line">for (ondemand::object car : parser.iterate(cars_json)) {</div>
<div class="line">  // Accessing a field by name</div>
<div class="line">  cout &lt;&lt; &quot;Make/Model: &quot; &lt;&lt; std::string_view(car[&quot;make&quot;]) &lt;&lt; &quot;/&quot; &lt;&lt; std::string_view(car[&quot;model&quot;]) &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  // Casting a JSON element to an integer</div>
<div class="line">  uint64_t year = car[&quot;year&quot;];</div>
<div class="line">  cout &lt;&lt; &quot;- This car is &quot; &lt;&lt; 2020 - year &lt;&lt; &quot;years old.&quot; &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  // Iterating through an array of floats</div>
<div class="line">  double total_tire_pressure = 0;</div>
<div class="line">  for (double tire_pressure : car[&quot;tire_pressure&quot;]) {</div>
<div class="line">    total_tire_pressure += tire_pressure;</div>
<div class="line">  }</div>
<div class="line">  cout &lt;&lt; &quot;- Average tire pressure: &quot; &lt;&lt; (total_tire_pressure / 4) &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is a different example illustrating the same ideas:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto points_json = R&quot;( [</div>
<div class="line">    {  &quot;12345&quot; : {&quot;x&quot;:12.34, &quot;y&quot;:56.78, &quot;z&quot;: 9998877}   },</div>
<div class="line">    {  &quot;12545&quot; : {&quot;x&quot;:11.44, &quot;y&quot;:12.78, &quot;z&quot;: 11111111}  }</div>
<div class="line">  ] )&quot;_padded;</div>
<div class="line"> </div>
<div class="line">// Parse and iterate through an array of objects</div>
<div class="line">for (ondemand::object points : parser.iterate(points_json)) {</div>
<div class="line">  for (auto point : points) {</div>
<div class="line">    cout &lt;&lt; &quot;id: &quot; &lt;&lt; std::string_view(point.unescaped_key()) &lt;&lt; &quot;: (&quot;;</div>
<div class="line">    cout &lt;&lt; point.value()[&quot;x&quot;].get_double() &lt;&lt; &quot;, &quot;;</div>
<div class="line">    cout &lt;&lt; point.value()[&quot;y&quot;].get_double() &lt;&lt; &quot;, &quot;;</div>
<div class="line">    cout &lt;&lt; point.value()[&quot;z&quot;].get_int64() &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And another one:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">auto abstract_json = R&quot;(</div>
<div class="line">  { &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } }</div>
<div class="line">)&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(abstract_json);</div>
<div class="line">cout &lt;&lt; doc[&quot;str&quot;][&quot;123&quot;][&quot;abc&quot;].get_double() &lt;&lt; endl; // Prints 3.14</div>
</div><!-- fragment --><ul>
<li><b>Extracting Values (without exceptions):</b> You can use a variant usage of <code>get()</code> with error codes to avoid exceptions. You first declare the variable of the appropriate type (<code>double</code>, <code>uint64_t</code>, <code>int64_t</code>, <code>bool</code>, <code>ondemand::object</code> and <code>ondemand::array</code>) and pass it by reference to <code>get()</code> which gives you back an error code: e.g.,</li>
</ul>
<div class="fragment"><div class="line">{c++}</div>
<div class="line"> auto abstract_json = R&quot;(</div>
<div class="line">   { &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } }</div>
<div class="line"> )&quot;_padded;</div>
<div class="line"> ondemand::parser parser;</div>
<div class="line"> </div>
<div class="line"> double value;</div>
<div class="line"> auto doc = parser.iterate(abstract_json);</div>
<div class="line"> auto error = doc[&quot;str&quot;][&quot;123&quot;][&quot;abc&quot;].get(value);</div>
<div class="line"> if (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line"> cout &lt;&lt; value &lt;&lt; endl; // Prints 3.14</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
