<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdjson: The Basics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logotiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdjson
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Ridiculously Fast JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Basics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An overview of what you need to know to use simdjson, with examples.</p>
<ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#including-simdjson">Including simdjson</a></li>
<li><a href="#using-simdjson-with-package-managers">Using simdjson with package managers</a></li>
<li><a href="#using-simdjson-as-a-cmake-dependency">Using simdjson as a CMake dependency</a></li>
<li><a href="#versions">Versions</a></li>
<li><a href="#the-basics-loading-and-parsing-json-documents">The Basics: Loading and Parsing JSON Documents</a></li>
<li><a href="#documents-are-iterators">Documents are Iterators</a></li>
<li><a href="#c11-support-and-string_view">C++11 Support and string_view</a></li>
<li><a href="#using-the-parsed-json">Using the Parsed JSON</a></li>
<li><a href="#minifying-json-strings-without-parsing">Minifying JSON strings without parsing</a></li>
<li><a href="#utf-8-validation-alone">UTF-8 validation (alone)</a></li>
<li><a href="#json-pointer">JSON Pointer</a></li>
<li><a href="#error-handling">Error Handling</a><ul>
<li><a href="#error-handling-example-without-exceptions">Error Handling Example without Exceptions</a></li>
<li><a href="#disabling-exceptions">Disabling Exceptions</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#current-location-in-documnet">Current location in document</a></li>
</ul>
</li>
<li><a href="#rewinding">Rewinding</a></li>
<li><a href="#direct-access-to-the-raw-string">Direct Access to the Raw String</a></li>
<li><a href="#newline-delimited-json-ndjson-and-json-lines">Newline-Delimited JSON (ndjson) and JSON lines</a></li>
<li><a href="#parsing-numbers-inside-strings">Parsing Numbers Inside Strings</a></li>
<li><a href="#dynamic-number-types">Dynamic Number Types</a></li>
<li><a href="#thread-safety">Thread Safety</a></li>
<li><a href="#standard-compliance">Standard Compliance</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md0"></a>
Requirements</h1>
<ul>
<li>A recent compiler (LLVM clang6 or better, GNU GCC 7.4 or better, Xcode 11 or better) on a 64-bit (PPC, ARM or x64 Intel/AMD) POSIX systems such as macOS, freeBSD or Linux. We require that the compiler supports the C++11 standard or better.</li>
<li>Visual Studio 2017 or better under 64-bit Windows. Users should target a 64-bit build (x64) instead of a 32-bit build (x86). We support the LLVM clang compiler under Visual Studio (clangcl) as well as as the regular Visual Studio compiler. We also support MinGW 64-bit under Windows.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Including simdjson</h1>
<p>To include simdjson, copy <a href="/singleheader/simdjson.h">simdjson.h</a> and <a href="/singleheader/simdjson.cpp">simdjson.cpp</a> into your project. Then include it in your project with:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line">using namespace simdjson; // optional</div>
</div><!-- fragment --><p>You can compile with:</p>
<div class="fragment"><div class="line">c++ myproject.cpp simdjson.cpp</div>
</div><!-- fragment --><p>Note:</p><ul>
<li>Users on macOS and other platforms where default compilers do not provide C++11 compliant by default should request it with the appropriate flag (e.g., <code>c++ -std=c++17 myproject.cpp simdjson.cpp</code>).</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Using simdjson with package managers</h1>
<p>You can install the simdjson library on your system or in your project using multiple package managers such as MSYS2, the conan package manager, vcpkg, brew, the apt package manager (debian-based Linux systems), the FreeBSD package manager (FreeBSD), and so on. <a href="https://github.com/simdjson/simdjson/wiki/Installing-simdjson-with-a-package-manager">Visit our wiki for more details</a>.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Using simdjson as a CMake dependency</h1>
<p>You can include the simdjson library as a CMake dependency by including the following lines in your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  simdjson</div>
<div class="line">  GIT_REPOSITORY https://github.com/simdjson/simdjson.git</div>
<div class="line">  GIT_TAG  tags/v0.9.6</div>
<div class="line">  GIT_SHALLOW TRUE)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(simdjson)</div>
</div><!-- fragment --><p>You should provide <code>GIT_TAG</code> with the release you need. If you omit <code>GIT_TAG ...</code>, you will work from the main branch of simdjson: we recommend that if you are working on production code, you always work from a release.</p>
<p>Elsewhere in your project, you can declare dependencies on simdjson with lines such as these:</p>
<div class="fragment"><div class="line">add_executable(myprogram myprogram.cpp)</div>
<div class="line">target_link_libraries(myprogram simdjson)</div>
</div><!-- fragment --><p>We recommend CMake version 3.15 or better.</p>
<p>See <a href="https://github.com/simdjson/cmake_demo_single_file">our CMake demonstration</a>. It works under Linux, FreeBSD, macOS and Windows (including Visual Studio).</p>
<p>The CMake build in simdjson can be taylored with a few variables. You can see the available variables and their default values by entering the <code>cmake -LA</code> command.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Versions</h1>
<p>Users are discouraged from building production code from the project's main branch. The main branch is used for development: it may contain new features but also additional bugs.</p>
<p>Users should pick a release. They should also access the documentation matching the release that they have chosen. Note that new features may be added over time.</p>
<p>Our releases are tagged using semantic versioning: the tags are made of three numbers prefixed by the letter <code>v</code> and separated by periods.</p>
<p>You can always find the latest release at the following hyperlink:</p>
<p><a href="https://github.com/simdjson/simdjson/releases/latest/">https://github.com/simdjson/simdjson/releases/latest/</a></p>
<p>The archive you download at this location contains its own corresponding documentation.</p>
<p>You can also choose to browse a specific version of the documentation and the code using GitHub, by appending the version number to the hyperlink, like so:</p>
<p><a href="https://github.com/simdjson/simdjson/blob/vx.y.z/doc/basics.md">https://github.com/simdjson/simdjson/blob/vx.y.z/doc/basics.md</a></p>
<p>where <code>x.y.z</code> should correspond to the version number you have chosen.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
The Basics: Loading and Parsing JSON Documents</h1>
<p>The simdjson library allows you to navigate and validate JSON documents (<a href="https://www.tbray.org/ongoing/When/201x/2017/12/14/rfc8259.html">RFC 8259</a>). As required by the standard, your JSON document should be Unicode (UTF-8) strings.</p>
<p>The simdjson library offers a tree-like <a href="https://en.wikipedia.org/wiki/API">API</a>, which you can access by creating a <code>ondemand::parser</code> and calling the <code>iterate()</code> method:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = padded_string::load(&quot;twitter.json&quot;);</div>
<div class="line">ondemand::document doc = parser.iterate(json); // position a pointer at the beginning of the JSON data</div>
</div><!-- fragment --><p>Or by creating a padded string&mdash;for efficiency reasons, simdjson requires a string with a few bytes (<code>simdjson::SIMDJSON_PADDING</code>) at the end&mdash;and calling <code>iterate()</code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = &quot;[1,2,3]&quot;_padded; // The _padded suffix creates a simdjson::padded_string instance</div>
<div class="line">ondemand::document doc = parser.iterate(json); // parse a string</div>
</div><!-- fragment --><p>If you have a buffer of your own with enough padding already (SIMDJSON_PADDING extra bytes allocated), you can use <code>padded_string_view</code> to pass it in:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">char json[3+SIMDJSON_PADDING];</div>
<div class="line">strcpy(json, &quot;[1]&quot;);</div>
<div class="line">ondemand::document doc = parser.iterate(json, strlen(json), sizeof(json));</div>
</div><!-- fragment --><p>The simdjson library will also accept <code>std::string</code> instances, as long as the <code>capacity()</code> of the string exceeds the <code>size()</code> by at least <code>SIMDJSON_PADDING</code>. You can increase the <code>capacity()</code> with the <code>reserve()</code> function of your strings.</p>
<p>We recommend against creating many <code>std::string</code> or many <code>std::padding_string</code> instances in your application to store your JSON data. Consider reusing the same buffers and limiting memory allocations.</p>
<p>By default, the simdjson library throws exceptions (<code>simdjson_error</code>) on errors. We omit <code>try</code>-<code>catch</code> clauses from our illustrating examples: if you omit <code>try</code>-<code>catch</code> in your code, an uncaught exception will halt your program. It is also possible to use simdjson without generating exceptions, and you may even build the library without exception support at all. See <a href="#error-handling">Error Handling</a> for details.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Documents are Iterators</h1>
<p>The simdjson library relies on an approach to parsing JSON that we call "On Demand". A <code>document</code> is <em>not</em> a fully-parsed JSON value; rather, it is an <b>iterator</b> over the JSON text. This means that while you iterate an array, or search for a field in an object, it is actually walking through the original JSON text, merrily reading commas and colons and brackets to make sure you get where you are going. This is the key to On Demand's performance: since it's just an iterator, it lets you parse values as you use them. And particularly, it lets you <em>skip</em> values you do not want to use.</p>
<p>We refer to "On Demand" as a front-end component since it is an interface between the low-level parsing functions and the user. It hides much of the complexity of parsing JSON documents.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Parser, Document and JSON Scope</h2>
<p>For code safety, you should keep (1) the <code>parser</code> instance, (2) the input string and (3) the document instance alive throughout your parsing. Additionally, you should follow the following rules:</p>
<ul>
<li>A <code>parser</code> may have at most one document open at a time, since it holds allocated memory used for the parsing.</li>
<li>By design, you should only have one <code>document</code> instance per JSON document. Thus, if you must pass a document instance to a function, you should avoid passing it by value: choose to pass it by reference instance to avoid the copy. (We also provide a <code>document_reference</code> class if you need to pass by value.)</li>
</ul>
<p>During the <code>iterate</code> call, the original JSON text is never modified&ndash;only read. After you are done with the document, the source (whether file or string) can be safely discarded.</p>
<p>For best performance, a <code>parser</code> instance should be reused over several files: otherwise you will needlessly reallocate memory, an expensive process. It is also possible to avoid entirely memory allocations during parsing when using simdjson. <a class="el" href="md_doc_performance.html">See our performance notes for details</a>.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
C++11 Support and string_view</h1>
<p>The simdjson library builds on compilers supporting the <a href="https://en.wikipedia.org/wiki/C%2B%2B11">C++11 standard</a>. It is also a strict requirement: we have no plan to support older C++ compilers.</p>
<p>We represent parsed Unicode (UTF-8) strings in simdjson using the <code>std::string_view</code> class. It avoids the need to copy the data, as would be necessary with the <code>std::string</code> class. It also avoids the pitfalls of null-terminated C strings. It makes it easier for our users to copy the data into their own favorite class instances (e.g., alternatives to <code>std::string</code>).</p>
<p>A <code>std::string_view</code> instance is effectively just a pointer to a region in memory representing a string. In simdjson, we return <code>std::string_view</code> instances that either point within the input string you parsed, or to a temporary string buffer inside our parser class instances. When using <code>std::string_view</code> instances, it is your responsibility to ensure that <code>std::string_view</code> instance does not outlive the pointed-to memory (e.g., either the input buffer or the parser instance). Furthermore, some operations reset the string buffer inside our parser instances: e.g., when we parse a new document. Thus a <code>std::string_view</code> instance is often best viewed as a temporary string value that is tied to the document you are parsing. At the cost of some memory allocation, you may convert your <code>std::string_view</code> instances for long-term storage into <code>std::string</code> instances: <code>std::string mycopy(view)</code> (C++17) or <code>std::string mycopy(view.begin(), view.end())</code> (prior to C++17).</p>
<p>The <code>std::string_view</code> class has become standard as part of C++17 but it is not always available on compilers which only supports C++11. When we detect that <code>string_view</code> is natively available, we define the macro <code>SIMDJSON_HAS_STRING_VIEW</code>.</p>
<p>When we detect that it is unavailable, we use <a href="https://github.com/martinmoene/string-view-lite">string-view-lite</a> as a substitute. In such cases, we use the type alias <code>using string_view = nonstd::string_view;</code> to offer the same API, irrespective of the compiler and standard library. The macro <code>SIMDJSON_HAS_STRING_VIEW</code> will be <em>undefined</em> to indicate that we emulate <code>string_view</code>.</p>
<p>Some users prefer to use non-JSON native encoding formats such as UTF-16 or UTF-32. Users may transcode the UTF-8 strings produced by the simdjson library to other formats. See the <a href="https://github.com/simdutf/simdutf">simdutf library</a>, for example.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Using the Parsed JSON</h1>
<p>Once you have a document (<code>simdjson::ondemand::document</code>), you can navigate it with idiomatic C++ iterators, operators and casts. Besides the documents instances and native types (<code>double</code>, <code>uint64_t</code>, <code>int64_t</code>, <code>bool</code>), we also access Unicode (UTF-8) strings (<code>std::string_view</code>), objects (<code>simdjson::ondemand::object</code>) and arrays (<code>simdjson::ondemand::array</code>). We also have a generic type (<code>simdjson::ondemand::value</code>) which represent a potential array or object, or scalar type (<code>double</code>, <code>uint64_t</code>, <code>int64_t</code>, <code>bool</code>, <code>null</code>, string) inside an array or an object. Both generic types (<code>simdjson::ondemand::document</code> and <code>simdjson::ondemand::value</code>) have a <code>type()</code> method returning a <code>json_type</code> value describing the value (<code>json_type::array</code>, <code>json_type::object</code>, <code>json_type::number</code>, <code>json_type::string</code>, <code>json_type::boolean</code>, <code>json_type::null</code>).</p>
<p>Advanced users who need to determine the number types (integer or float) dynamically, should review our section <a href="#dynamic-number-types">dynamic number types</a>. Indeed, we have an additional <code>ondemand::number</code> type which may represent either integers or floating-point values, depending on how the numbers are formatted. floating-point values followed by an integer. While you are accessing the document, the <code>document</code> instance should remain in scope: it is your "iterator" which keeps track of where you are in the JSON document. By design, there is one and only one <code>document</code> instance per JSON document.</p>
<p>The following specific instructions indicate how to use the JSON when exceptions are enabled, but simdjson has full, idiomatic support for users who avoid exceptions. See <a href="basics.md#error-handling">the simdjson error handling documentation</a> for more.</p>
<ul>
<li><b>Validate What You Use:</b> When calling <code>iterate</code>, the document is quickly indexed. If it is not a valid Unicode (UTF-8) string or if there is an unclosed string, an error may be reported right away. However, it is not fully validated. On Demand only fully validates the values you use and the structure leading to it.</li>
<li><b>Extracting Values:</b> You can cast a JSON element to a native type: <code>double(element)</code> or <code>double x = json_element</code>. This works for <code>std::string_view</code>, double, uint64_t, int64_t, bool, ondemand::object and ondemand::array. At this point, the number, string or boolean will be parsed, or the initial <code>[</code> or <code>{</code> will be verified. An exception is thrown if the cast is not possible.</li>
</ul>
<blockquote class="doxtable">
<p>IMPORTANT NOTE: values can only be parsed once. Since documents are <em>iterators</em>, once you have parsed a value (such as by casting to double), you cannot get at it again. </p>
</blockquote>
<p>* <b>Field Access:</b> To get the value of the "foo" field in an object, use <code>object["foo"]</code>. This will scan through the object looking for the field with the matching string, doing a character-by-character comparison. For efficiency reason, you should avoid looking up the same field repeatedly: e.g., do not do <code>object["foo"]</code> followed by <code>object["foo"]</code> with the same <code>object</code> instance.</p>
<blockquote class="doxtable">
<p>NOTE: JSON allows you to escape characters in keys. E.g., the key <code>"date"</code> may be written as <code>"\u0064\u0061\u0074\u0065"</code>. By default, simdjson does <em>not</em> unescape keys when matching by default. Thus if you search for the key <code>"date"</code> and the JSON document uses <code>"\u0064\u0061\u0074\u0065"</code> as a key, it will not be recognized. This is not generally a problem. Nevertheless, if you do need to support escaped keys, the method <code>unescaped_key()</code> provides the desired unescaped keys by parsing and writing out the unescaped keys to a string buffer and returning a <code>std::string_view</code> instance. You should expect a performance penalty when using <code>unescaped_key()</code>. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">&gt; auto json = R&quot;({&quot;k\u0065y&quot;: 1})&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">ondemand::object object = doc.get_object();</div>
<div class="line">for(auto field : object) {</div>
<div class="line">   // parses and writes out the key, after unescaping it,</div>
<div class="line">   // to a string buffer. It causes a performance penalty.</div>
<div class="line">   std::string_view keyv = field.unescaped_key();</div>
<div class="line">   if(keyv == &quot;key&quot;) { std::cout &lt;&lt; uint64_t(field.value()); }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>By default, field lookup is order-insensitive, so you can look up values in any order. However, we still encourage you to look up fields in the order you expect them in the JSON, as it is still faster.</p>
<p>If you want to enforce finding fields in order, you can use <code>object.find_field("foo")</code> instead. This will only look forward, and will fail to find fields in the wrong order: for example, this will fail:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = R&quot;(  { &quot;x&quot;: 1, &quot;y&quot;: 2 }  )&quot;_padded;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">double y = doc.find_field(&quot;y&quot;); // The cursor is now after the 2 (at })</div>
<div class="line">double x = doc.find_field(&quot;x&quot;); // This fails, because there are no more fields after &quot;y&quot;</div>
</div><!-- fragment --><p>By contrast, using the default (order-insensitive) lookup succeeds:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto json = R&quot;(  { &quot;x&quot;: 1, &quot;y&quot;: 2 }  )&quot;_padded;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">double y = doc[&quot;y&quot;]; // The cursor is now after the 2 (at })</div>
<div class="line">double x = doc[&quot;x&quot;]; // Success: [] loops back around to find &quot;x&quot;</div>
</div><!-- fragment --> </blockquote>
<p>* <b>Array Iteration:</b> To iterate through an array, use <code>for (auto value : array) { ... }</code>. This will step through each value in the JSON array.</p>
<p>If you know the type of the value, you can cast it right there, too! <code>for (double value : array) { ... }</code>.</p><ul>
<li><b>Object Iteration:</b> You can iterate through an object's fields, as well: <code>for (auto field : object) { ... }</code><ul>
<li><code>field.unescaped_key()</code> will get you the unescaped key string.</li>
<li><code>field.value()</code> will get you the value, which you can then use all these other methods on.</li>
</ul>
</li>
<li><b>Array Index:</b> Because it is forward-only, you cannot look up an array element by index by index. Instead, you should iterate through the array and keep an index yourself.</li>
<li><b>Output to strings:</b> Given a document, a value, an array or an object in a JSON document, you can output a JSON string version suitable to be parsed again as JSON content: <code>simdjson::to_json_string(element)</code>. A call to <code>to_json_string</code> consumes fully the element: if you apply it on a document, the JSON pointer is advanced to the end of the document. The <code>simdjson::to_json_string</code> does not allocate memory. The <code>to_json_string</code> function should not be confused with retrieving the value of a string instance which are escaped and represented using a lightweight <code>std::string_view</code> instance pointing at an internal string buffer inside the parser instance. To illustrate, the first of the following two code segments will print the unescaped string <code>"test"</code> complete with the quote whereas the second one will print the escaped content of the string (without the quotes). <blockquote class="doxtable">
<p>```C++ // serialize a JSON to an escaped std::string instance so that it can be parsed again as JSON auto silly_json = R"( { "test": "result"  }  )"_padded; ondemand::document doc = parser.iterate(silly_json); std::cout &lt;&lt; simdjson::to_json_string(doc["test"]) &lt;&lt; std::endl; // Requires simdjson 1.0 or better &gt;`<code> </code>C++ // retrieves an unescaped string value as a string_view instance auto silly_json = R"( { "test": "result"  }  )"_padded; ondemand::document doc = parser.iterate(silly_json); std::cout &lt;&lt; std::string_view(doc["test"]) &lt;&lt; std::endl; &gt;```<code> &lt;/blockquote&gt; You can use</code>to_json_string<code>to efficiently extract components of a JSON document to reconstruct a new JSON document, as in the following example: &lt;blockquote&gt;</code>``C++ auto cars_json = R"( [
  { "make": "Toyota", "model": "Camry",  "year": 2018, "tire_pressure": [ 40.1, 39.9, 37.7, 40.4 ] },
  { "make": "Kia",    "model": "Soul",   "year": 2012, "tire_pressure": [ 30.1, 31.0, 28.6, 28.7 ] },
  { "make": "Toyota", "model": "Tercel", "year": 1999, "tire_pressure": [ 29.8, 30.0, 30.2, 30.5 ] }
] )"_padded; std::vector&lt;std::string_view&gt; arrays; // We are going to collect string_view instances which point inside the <code>cars_json</code> string // and are therefore valid as long as <code>cars_json</code> remains in scope. { ondemand::parser parser; for (ondemand::object car : parser.iterate(cars_json)) { if(uint64_t(car["year"]) &gt; 2000) { arrays.push_back(simdjson::to_json_string(car["tire_pressure"])); } } } // We can now convert to a JSON string: std::ostringstream oss; oss &lt;&lt; "["; for(size_t i = 0; i &lt; arrays.size(); i++) { if(i&gt;0) { oss &lt;&lt; ","; } oss &lt;&lt; arrays[i]; } oss &lt;&lt; "]"; auto json_string = oss.str(); // json_string == "[[ 40.1, 39.9, 37.7, 40.4 ],[ 30.1, 31.0, 28.6, 28.7 ]]" &gt;```<code> &lt;/blockquote&gt;* **Extracting Values (without exceptions):** You can use a variant usage of</code>get()<code>with error codes to avoid exceptions. You first declare the variable of the appropriate type (</code>double<code>, </code>uint64_t<code>,</code>int64_t<code>,</code>bool<code>,</code>ondemand::object&lt;tt&gt;andondemand::array&lt;tt&gt;) and pass it by reference toget()` which gives you back an error code: e.g.,</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line"> auto abstract_json = R&quot;(</div>
<div class="line">   { &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } }</div>
<div class="line"> )&quot;_padded;</div>
<div class="line"> ondemand::parser parser;</div>
<div class="line"> </div>
<div class="line"> double value;</div>
<div class="line"> auto doc = parser.iterate(abstract_json);</div>
<div class="line"> auto error = doc[&quot;str&quot;][&quot;123&quot;][&quot;abc&quot;].get(value);</div>
<div class="line"> if (error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line"> cout &lt;&lt; value &lt;&lt; endl; // Prints 3.14</div>
</div><!-- fragment --><p> This examples also show how we can string several operations and only check for the error once, a strategy we call <em>error chaining</em>. Though error chaining makes the code very compact, it also makes error reporting less precise: in this instance, you may get the same error whether the field "str", "123" or "abc" is missing. If you need to break down error handling per operation, avoid error chaining.</p>
</blockquote>
</li>
<li><b>Counting elements in arrays:</b> Sometimes it is useful to scan an array to determine its length prior to parsing it. For this purpose, <code>array</code> instances have a <code>count_elements</code> method. Users should be aware that the <code>count_elements</code> method can be costly since it requires scanning the whole array. You may use it as follows if your document is itself an array:</li>
</ul>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> auto cars_json = R&quot;( [ 40.1, 39.9, 37.7, 40.4 ] )&quot;_padded;</div>
<div class="line"> auto doc = parser.iterate(cars_json);</div>
<div class="line"> size_t count = doc.count_elements(); // requires simdjson 1.0 or better</div>
<div class="line"> std::vector&lt;double&gt; values(count);</div>
<div class="line"> size_t index = 0;</div>
<div class="line"> for(double x : doc) { values[index++] = x; }</div>
</div><!-- fragment --><p> If you access an array inside a document, you can use the <code>count_elements</code> method as follow. You should not let the array instance go out of scope before consuming it after calling the <code>count_elements</code> method: </p><div class="fragment"><div class="line">ondemand::parser parser;</div>
<div class="line">auto cars_json = R&quot;( { &quot;test&quot;:[ { &quot;val1&quot;:1, &quot;val2&quot;:2 }, { &quot;val1&quot;:1, &quot;val2&quot;:2 } ] }   )&quot;_padded;</div>
<div class="line">auto doc = parser.iterate(cars_json);</div>
<div class="line">auto test_array = doc.find_field(&quot;test&quot;).get_array();</div>
<div class="line">size_t count = test_array.count_elements(); // requires simdjson 1.0 or better</div>
<div class="line">std::cout &lt;&lt; &quot;Number of elements: &quot; &lt;&lt;  count &lt;&lt; std::endl;</div>
<div class="line">for(ondemand::object elem: test_array) {</div>
<div class="line">   std::cout &lt;&lt; simdjson::to_string(elem);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Counting fields in objects:</b> Other times, it is useful to scan an object to determine the number of fields prior to parsing it. For this purpose, <code>object</code> instances have a <code>count_fields</code> method. Again, users should be aware that the <code>count_fields</code> method can be costly since it requires scanning the whole objects. You may use it as follows if your document is itself an object:</li>
</ul>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> ondemand::parser parser;</div>
<div class="line"> auto json = R&quot;( { &quot;test&quot;:{ &quot;val1&quot;:1, &quot;val2&quot;:2 } }   )&quot;_padded;</div>
<div class="line"> auto doc = parser.iterate(json);</div>
<div class="line"> size_t count = doc.count_fields(); // requires simdjson 1.0 or better</div>
<div class="line"> std::cout &lt;&lt; &quot;Number of fields: &quot; &lt;&lt;  new_count &lt;&lt; std::endl; // Prints &quot;Number of fields: 1&quot;</div>
</div><!-- fragment --><p> Similarly to <code>count_elements</code>, you should not let an object instance go out of scope before consuming it after calling the <code>count_fields</code> method. If you access an object inside a document, you can use the <code>count_fields</code> method as follow. </p><div class="fragment"><div class="line">ondemand::parser parser;</div>
<div class="line">auto json = R&quot;( { &quot;test&quot;:{ &quot;val1&quot;:1, &quot;val2&quot;:2 } }   )&quot;_padded;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">auto test_object = doc.find_field(&quot;test&quot;).get_object();</div>
<div class="line">size_t count = test_object.count_fields(); // requires simdjson 1.0 or better</div>
<div class="line">std::cout &lt;&lt; &quot;Number of fields: &quot; &lt;&lt;  count &lt;&lt; std::endl; // Prints &quot;Number of fields: 2&quot;</div>
</div><!-- fragment --><ul>
<li><b>Tree Walking and JSON Element Types:</b> Sometimes you don't necessarily have a document with a known type, and are trying to generically inspect or walk over JSON elements. To do that, you can use iterators and the <code>type()</code> method. You can also represent arbitrary JSON values with <code>ondemand::value</code> instances: it can represent anything except a scalar document (lone number, string, null or Boolean). You can check for scalar documents with the method <code>scalar()</code>. For example, the following is a quick and dirty recursive function that verbosely prints the JSON document as JSON. This example also illustrates lifecycle requirements: the <code>document</code> instance holds the iterator. The document must remain in scope while you are accessing instances of <code>value</code>, <code>object</code> and <code>array</code>. <div class="fragment"><div class="line">{c++}</div>
<div class="line"> void recursive_print_json(ondemand::value element) {</div>
<div class="line">   bool add_comma;</div>
<div class="line">   switch (element.type()) {</div>
<div class="line">   case ondemand::json_type::array:</div>
<div class="line">     cout &lt;&lt; &quot;[&quot;;</div>
<div class="line">     add_comma = false;</div>
<div class="line">     for (auto child : element.get_array()) {</div>
<div class="line">       if (add_comma) {</div>
<div class="line">         cout &lt;&lt; &quot;,&quot;;</div>
<div class="line">       }</div>
<div class="line">       // We need the call to value() to get</div>
<div class="line">       // an ondemand::value type.</div>
<div class="line">       recursive_print_json(child.value());</div>
<div class="line">       add_comma = true;</div>
<div class="line">     }</div>
<div class="line">     cout &lt;&lt; &quot;]&quot;;</div>
<div class="line">     break;</div>
<div class="line">   case ondemand::json_type::object:</div>
<div class="line">     cout &lt;&lt; &quot;{&quot;;</div>
<div class="line">     add_comma = false;</div>
<div class="line">     for (auto field : element.get_object()) {</div>
<div class="line">       if (add_comma) {</div>
<div class="line">         cout &lt;&lt; &quot;,&quot;;</div>
<div class="line">       }</div>
<div class="line">       // key() returns the key as it appears in the raw</div>
<div class="line">       // JSON document, if we want the unescaped key,</div>
<div class="line">       // we should do field.unescaped_key().</div>
<div class="line">       cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; field.key() &lt;&lt; &quot;\&quot;: &quot;;</div>
<div class="line">       recursive_print_json(field.value());</div>
<div class="line">       add_comma = true;</div>
<div class="line">     }</div>
<div class="line">     cout &lt;&lt; &quot;}\n&quot;;</div>
<div class="line">     break;</div>
<div class="line">   case ondemand::json_type::number:</div>
<div class="line">     // assume it fits in a double</div>
<div class="line">     cout &lt;&lt; element.get_double();</div>
<div class="line">     break;</div>
<div class="line">   case ondemand::json_type::string:</div>
<div class="line">     // get_string() would return escaped string, but</div>
<div class="line">     // we are happy with unescaped string.</div>
<div class="line">     cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; element.get_raw_json_string() &lt;&lt; &quot;\&quot;&quot;;</div>
<div class="line">     break;</div>
<div class="line">   case ondemand::json_type::boolean:</div>
<div class="line">     cout &lt;&lt; element.get_bool();</div>
<div class="line">     break;</div>
<div class="line">   case ondemand::json_type::null:</div>
<div class="line">     cout &lt;&lt; &quot;null&quot;;</div>
<div class="line">     break;</div>
<div class="line">   }</div>
<div class="line"> }</div>
<div class="line"> void basics_treewalk() {</div>
<div class="line">   padded_string json = R&quot;( [</div>
<div class="line">   { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">   { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">   { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line"> ] )&quot;_padded;</div>
<div class="line">   ondemand::parser parser;</div>
<div class="line">   ondemand::document doc = parser.iterate(json);</div>
<div class="line">   ondemand::value val = doc;</div>
<div class="line">   recursive_print_json(val);</div>
<div class="line">   std::cout &lt;&lt; std::endl;</div>
<div class="line"> }</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
Using the Parsed JSON: Additional examples</h2>
<p>Let us review these concepts with some additional examples. For simplicity, we omit the include clauses (<code>#include "simdjson.h"</code>) as well as namespace-using clauses (<code>using namespace simdjson;</code>).</p>
<p>The first example illustrates how we can chain operations. In this instance, we repeatedly select keys using the bracket operator (<code>doc["str"]</code>) and then finally request a number (using <code>get_double()</code>). It is safe to write code in this manner: if any step causes an error, the error status propagates and an exception is thrown at the end. You do not need to constantly check for errors.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">auto abstract_json = R&quot;(</div>
<div class="line">  { &quot;str&quot; : { &quot;123&quot; : {&quot;abc&quot; : 3.14 } } }</div>
<div class="line">)&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(abstract_json);</div>
<div class="line">cout &lt;&lt; doc[&quot;str&quot;][&quot;123&quot;][&quot;abc&quot;].get_double() &lt;&lt; endl; // Prints 3.14</div>
</div><!-- fragment --><p>In the following example, we start with a JSON document that contains an array of objects. We iterate through the objects using a for-loop. Within each object, we use the bracket operator (e.g., <code>car["make"]</code>) to select values. We also show how we can iterate through an array, corresponding to the key <code>tire_pressure</code>, that is contained inside each object.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line"> </div>
<div class="line">// Iterating through an array of objects</div>
<div class="line">for (ondemand::object car : parser.iterate(cars_json)) {</div>
<div class="line">  // Accessing a field by name</div>
<div class="line">  cout &lt;&lt; &quot;Make/Model: &quot; &lt;&lt; std::string_view(car[&quot;make&quot;]) &lt;&lt; &quot;/&quot; &lt;&lt; std::string_view(car[&quot;model&quot;]) &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  // Casting a JSON element to an integer</div>
<div class="line">  uint64_t year = car[&quot;year&quot;];</div>
<div class="line">  cout &lt;&lt; &quot;- This car is &quot; &lt;&lt; 2020 - year &lt;&lt; &quot;years old.&quot; &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">  // Iterating through an array of floats</div>
<div class="line">  double total_tire_pressure = 0;</div>
<div class="line">  for (double tire_pressure : car[&quot;tire_pressure&quot;]) {</div>
<div class="line">    total_tire_pressure += tire_pressure;</div>
<div class="line">  }</div>
<div class="line">  cout &lt;&lt; &quot;- Average tire pressure: &quot; &lt;&lt; (total_tire_pressure / 4) &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following example illustrates how you may also iterate through object values, effectively visiting all key-value pairs in the object.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line">using namespace std;</div>
<div class="line">using namespace simdjson;</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto points_json = R&quot;( [</div>
<div class="line">      {  &quot;12345&quot; : {&quot;x&quot;:12.34, &quot;y&quot;:56.78, &quot;z&quot;: 9998877}   },</div>
<div class="line">      {  &quot;12545&quot; : {&quot;x&quot;:11.44, &quot;y&quot;:12.78, &quot;z&quot;: 11111111}  }</div>
<div class="line">    ] )&quot;_padded;</div>
<div class="line"> </div>
<div class="line">// Parse and iterate through an array of objects</div>
<div class="line">for (ondemand::object points : parser.iterate(points_json)) {</div>
<div class="line">  // Iterating through an object, you iterate through key-value pairs (a &#39;field&#39;).</div>
<div class="line">  for (auto point : points) {</div>
<div class="line">    // Get the key corresponding the the field &#39;point&#39;.</div>
<div class="line">    cout &lt;&lt; &quot;id: &quot; &lt;&lt; std::string_view(point.unescaped_key()) &lt;&lt; &quot;: (&quot;;</div>
<div class="line">    // Get the value corresponding the the field &#39;point&#39;.</div>
<div class="line">    ondemand::object xyz = point.value();</div>
<div class="line">    cout &lt;&lt; xyz[&quot;x&quot;].get_double() &lt;&lt; &quot;, &quot;;</div>
<div class="line">    cout &lt;&lt; xyz[&quot;y&quot;].get_double() &lt;&lt; &quot;, &quot;;</div>
<div class="line">    cout &lt;&lt; xyz[&quot;z&quot;].get_int64() &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
Minifying JSON strings without parsing</h1>
<p>In some cases, you may have valid JSON strings that you do not wish to parse but that you wish to minify. That is, you wish to remove all unnecessary spaces. We have a fast function for this purpose (<code>simdjson::minify(const char * input, size_t length, const char * output, size_t&amp; new_length)</code>). This function does not validate your content, and it does not parse it. It is much faster than parsing the string and re-serializing it in minified form (<code>simdjson::minify(parser.parse())</code>). Usage is relatively simple. You must pass an input pointer with a length parameter, as well as an output pointer and an output length parameter (by reference). The output length parameter is not read, but written to. The output pointer should point to a valid memory region that is as large as the original string length. The input pointer and input length are read, but not written to.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> // Starts with a valid JSON document as a string.</div>
<div class="line"> // It does not have to be null-terminated.</div>
<div class="line"> const char * some_string = &quot;[ 1, 2, 3, 4] &quot;;</div>
<div class="line"> size_t length = std::strlen(some_string);</div>
<div class="line"> // Create a buffer to receive the minified string. Make sure that there is enough room (length bytes).</div>
<div class="line"> std::unique_ptr&lt;char[]&gt; buffer{new char[length]};</div>
<div class="line"> size_t new_length{}; // It will receive the minified length.</div>
<div class="line"> auto error = simdjson::minify(some_string, length, buffer.get(), new_length);</div>
<div class="line"> // The buffer variable now has &quot;[1,2,3,4]&quot; and new_length has value 9.</div>
</div><!-- fragment --><p>Though it does not validate the JSON input, it will detect when the document ends with an unterminated string. E.g., it would refuse to minify the string <code>"this string is not terminated</code> because of the missing final quote.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
UTF-8 validation (alone)</h1>
<p>The simdjson library has fast functions to validate UTF-8 strings. They are many times faster than most functions commonly found in libraries. You can use our fast functions, even if you do not care about JSON.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> const char * some_string = &quot;[ 1, 2, 3, 4] &quot;;</div>
<div class="line"> size_t length = std::strlen(some_string);</div>
<div class="line"> bool is_ok = simdjson::validate_utf8(some_string, length);</div>
</div><!-- fragment --><p>The UTF-8 validation function merely checks that the input is valid UTF-8: it works with strings in general, not just JSON strings.</p>
<p>Your input string does not need any padding. Any string will do. The <code>validate_utf8</code> function does not do any memory allocation on the heap, and it does not throw exceptions.</p>
<p>If you find yourself needing only fast Unicode functions, consider using the simdutf library instead: <a href="https://github.com/simdutf/simdutf">https://github.com/simdutf/simdutf</a></p>
<h1><a class="anchor" id="autotoc_md13"></a>
JSON Pointer</h1>
<p>The simdjson library also supports <a href="https://tools.ietf.org/html/rfc6901">JSON pointer</a> through the <code>at_pointer()</code> method, letting you reach further down into the document in a single call. JSON pointer is supported by both the <a href="https://github.com/simdjson/simdjson/blob/master/doc/dom.md#json-pointer">DOM approach</a> as well as the On Demand approach.</p>
<p><b>Note:</b> The On Demand implementation of JSON pointer relies on <code>find_field</code> which implies that it does not unescape keys when matching.</p>
<p>Consider the following example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto cars = parser.iterate(cars_json);</div>
<div class="line">cout &lt;&lt; cars.at_pointer(&quot;/0/tire_pressure/1&quot;) &lt;&lt; endl; // Prints 39.9</div>
</div><!-- fragment --><p>A JSON Path is a sequence of segments each starting with the '/' character. Within arrays, an integer index allows you to select the indexed node. Within objects, the string value of the key allows you to select the value. If your keys contain the characters '/' or '~', they must be escaped as '~1' and '~0' respectively. An empty JSON Path refers to the whole document.</p>
<p>For multiple JSON pointer queries on a document, one can call <code>at_pointer</code> multiple times.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto cars_json = R&quot;( [</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">  { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto cars = parser.iterate(cars_json);</div>
<div class="line">size_t size = cars.count_elements();</div>
<div class="line"> </div>
<div class="line">for (size_t i = 0; i &lt; size; i++) {</div>
<div class="line">    std::string json_pointer = &quot;/&quot; + std::to_string(i) + &quot;/tire_pressure/1&quot;;</div>
<div class="line">    double x = cars.at_pointer(json_pointer);</div>
<div class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; // Prints 39.9, 31 and 30</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that <code>at_pointer</code> calls <a href="#rewind"><code>rewind</code></a> to reset the parser at the beginning of the document. Hence, it invalidates all previously parsed values, objects and arrays: make sure to consume the values between each call to <code>at_pointer</code>. Consider the following example where one wants to store each object from the JSON into a vector of <code>struct car_type</code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct car_type {</div>
<div class="line">    std::string make;</div>
<div class="line">    std::string model;</div>
<div class="line">    uint64_t year;</div>
<div class="line">    std::vector&lt;double&gt; tire_pressure;</div>
<div class="line">    car_type(std::string_view _make, std::string_view _model, uint64_t _year,</div>
<div class="line">      std::vector&lt;double&gt;&amp;&amp; _tire_pressure) :</div>
<div class="line">      make{_make}, model{_model}, year(_year), tire_pressure(_tire_pressure) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">auto cars_json = R&quot;( [</div>
<div class="line">{ &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">{ &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">{ &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">] )&quot;_padded;</div>
<div class="line"> </div>
<div class="line">ondemand::parser parser;</div>
<div class="line">ondemand::document cars;</div>
<div class="line">std::vector&lt;double&gt; measured;</div>
<div class="line">parser.iterate(cars_json).get(cars);</div>
<div class="line">std::vector&lt;car_type&gt; content;</div>
<div class="line">for (int i = 0; i &lt; 3; i++) {</div>
<div class="line">    ondemand::object obj;</div>
<div class="line">    std::string json_pointer = &quot;/&quot; + std::to_string(i);</div>
<div class="line">    // Each successive at_pointer call invalidates</div>
<div class="line">    // previously parsed values, strings, objects and array.</div>
<div class="line">    cars.at_pointer(json_pointer).get(obj);</div>
<div class="line">    // We materialize the object.</div>
<div class="line">    std::string_view make;</div>
<div class="line">    ASSERT_SUCCESS(obj[&quot;make&quot;].get(make));</div>
<div class="line">    std::string_view model;</div>
<div class="line">    ASSERT_SUCCESS(obj[&quot;model&quot;].get(model));</div>
<div class="line">    uint64_t year;</div>
<div class="line">    ASSERT_SUCCESS(obj[&quot;year&quot;].get(year));</div>
<div class="line">    // We materialize the array.</div>
<div class="line">    ondemand::array arr;</div>
<div class="line">    ASSERT_SUCCESS(obj[&quot;tire_pressure&quot;].get(arr));</div>
<div class="line">    std::vector&lt;double&gt; values;</div>
<div class="line">    for(auto x : arr) {</div>
<div class="line">        double value_double;</div>
<div class="line">        ASSERT_SUCCESS(x.get(value_double));</div>
<div class="line">        values.push_back(value_double);</div>
<div class="line">    }</div>
<div class="line">    content.emplace_back(make, model, year, std::move(values));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Furthermore, <code>at_pointer</code> calls <code>rewind</code> at the beginning of the call (i.e. the document is not reset after <code>at_pointer</code>). Consider the following example,</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto json = R&quot;( {</div>
<div class="line">  &quot;k0&quot;: 27,</div>
<div class="line">  &quot;k1&quot;: [13,26],</div>
<div class="line">  &quot;k2&quot;: true</div>
<div class="line">} )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">std::cout &lt;&lt; doc.at_pointer(&quot;/k1/1&quot;) &lt;&lt; std::endl; // Prints 26</div>
<div class="line">std::cout &lt;&lt; doc.at_pointer(&quot;/k2&quot;) &lt;&lt; std::endl; // Prints true</div>
<div class="line">doc.rewind();   // Need to manually rewind to be able to use find_field properly from start of document</div>
<div class="line">std::cout &lt;&lt; doc.find_field(&quot;k0&quot;) &lt;&lt; std::endl; // Prints 27</div>
</div><!-- fragment --><p>When the JSON path is the empty string (<code>""</code>) applied to a scalar document (lone string, number, Boolean or null), a SCALAR_DOCUMENT_AS_VALUE error is returned because scalar document cannot be represented as <code>value</code> instances. You can check that a document is a scalar with the method <code>scalar()</code>.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Error Handling</h1>
<p>Error handing with exception and a single try/catch clause makes the code simple, but it gives you little control over errors. For easier debugging or more robust error handling, you may want to consider our exception-free approach.</p>
<p>The entire simdjson API is usable with and without exceptions. All simdjson APIs that can fail return <code>simdjson_result&lt;T&gt;</code>, which is a &lt;value, error_code&gt; pair. You can retrieve the value with .get() without generating an exception, like so:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::element doc;</div>
<div class="line">auto error = parser.iterate(json).get(doc);</div>
<div class="line">if (error) { cerr &lt;&lt; error &lt;&lt; endl; exit(1); }</div>
</div><!-- fragment --><p>When you use the code this way, it is your responsibility to check for error before using the result: if there is an error, the result value will not be valid and using it will caused undefined behavior. Most compilers should be able to help you if you activate the right set of warnings: they can identify variables that are written to but never otherwise accessed.</p>
<p>Let us illustrate with an example where we try to access a number that is not valid (<code>3.14.1</code>). If we want to proceed without throwing and catching exceptions, we can do so as follows:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">bool simple_error_example() {</div>
<div class="line">    ondemand::parser parser;</div>
<div class="line">    auto json = R&quot;({&quot;bad number&quot;:3.14.1 })&quot;_padded;</div>
<div class="line">    ondemand::document doc;</div>
<div class="line">    if( parser.iterate(json).get(doc) != SUCCESS ) { return false; }</div>
<div class="line">    double x;</div>
<div class="line">    auto error = doc[&quot;bad number&quot;].get_double().get(x);</div>
<div class="line">    // returns &quot;simdjson::NUMBER_ERROR&quot;</div>
<div class="line">    if(error != SUCCESS) {</div>
<div class="line">      std::cout &lt;&lt; error &lt;&lt; std::endl;</div>
<div class="line">      return false;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; &quot;Got &quot; &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">    return true;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Observe how we verify the error variable before accessing the retrieved number (variable <code>x</code>).</p>
<p>The equivalent with exception handling might look as follows.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> bool simple_error_example_except() {</div>
<div class="line">   TEST_START();</div>
<div class="line">   ondemand::parser parser;</div>
<div class="line">   auto json = R&quot;({&quot;bad number&quot;:3.14.1 })&quot;_padded;</div>
<div class="line">   try {</div>
<div class="line">     ondemand::document doc = parser.iterate(json);</div>
<div class="line">     double x = doc[&quot;bad number&quot;].get_double();</div>
<div class="line">     std::cout &lt;&lt; &quot;Got &quot; &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">     return true;</div>
<div class="line">   } catch(simdjson_error&amp; e) {</div>
<div class="line">     // e.error() == NUMBER_ERROR</div>
<div class="line">     std::cout &lt;&lt; e.error() &lt;&lt; std::endl;</div>
<div class="line">     return false;</div>
<div class="line">   }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Notice how we can retrieve the exact error condition (in this instance <code>simdjson::NUMBER_ERROR</code>) from the exception.</p>
<p>We can write a "quick start" example where we attempt to parse the following JSON file and access some data, without triggering exceptions: </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;statuses&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;id&quot;: 505874924095815700</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;id&quot;: 505874922023837700</div>
<div class="line">    }</div>
<div class="line">  ],</div>
<div class="line">  &quot;search_metadata&quot;: {</div>
<div class="line">    &quot;count&quot;: 100</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our program loads the file, selects value corresponding to key <code>"search_metadata"</code> which expected to be an object, and then it selects the key <code>"count"</code> within that object.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">  simdjson::ondemand::parser parser;</div>
<div class="line">  auto error = padded_string::load(&quot;twitter.json&quot;).get(json);</div>
<div class="line">  if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">  simdjson::ondemand::document tweets;</div>
<div class="line">  error = parser.iterate(json).get(tweets);</div>
<div class="line">  if( error ) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">  simdjson::ondemand::value res;</div>
<div class="line">  error = tweets[&quot;search_metadata&quot;][&quot;count&quot;].get(res);</div>
<div class="line">  if (error != SUCCESS) {</div>
<div class="line">    std::cerr &lt;&lt; &quot;could not access keys : &quot; &lt;&lt; error &lt;&lt; std::endl;</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; res &lt;&lt; &quot; results.&quot; &lt;&lt; std::endl;</div>
<div class="line">  return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following is a similar example where one wants to get the id of the first tweet without triggering exceptions. To do this, we use <code>["statuses"].at(0)["id"]</code>. We break that expression down:</p>
<ul>
<li>Get the list of tweets (the <code>"statuses"</code> key of the document) using <code>["statuses"]</code>). The result is expected to be an array.</li>
<li>Get the first tweet using <code>.at(0)</code>. The result is expected to be an object.</li>
<li>Get the id of the tweet using ["id"]. We expect the value to be a non-negative integer.</li>
</ul>
<p>Observe how we use the <code>at</code> method when querying an index into an array, and not the bracket operator.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">  simdjson::ondemand::parser parser;</div>
<div class="line">  simdjson::ondemand::document tweets;</div>
<div class="line">  padded_string json;</div>
<div class="line">  auto error = padded_string::load(&quot;twitter.json&quot;).get(json);</div>
<div class="line">  if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">  error = parser.iterate(json).get(tweets);</div>
<div class="line">  if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">  uint64_t identifier;</div>
<div class="line">  error = tweets[&quot;statuses&quot;].at(0)[&quot;id&quot;].get(identifier);</div>
<div class="line">  if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return EXIT_FAILURE; }</div>
<div class="line">  std::cout &lt;&lt; identifier &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Error Handling Examples without Exceptions</h2>
<p>This is how the example in "Using the Parsed JSON" could be written using only error code checking (without exceptions):</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">bool parse() {</div>
<div class="line">  ondemand::parser parser;</div>
<div class="line">  auto cars_json = R&quot;( [</div>
<div class="line">    { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">    { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">    { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line">  ] )&quot;_padded;</div>
<div class="line">  ondemand::document doc;</div>
<div class="line"> </div>
<div class="line">  // Iterating through an array of objects</div>
<div class="line">  auto error = parser.iterate(cars_json).get(doc);</div>
<div class="line">  if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return false; }</div>
<div class="line">  ondemand::array cars;</div>
<div class="line">  error = doc.get_array().get(cars);</div>
<div class="line"> </div>
<div class="line">  for (auto car_value : cars) {</div>
<div class="line">    ondemand::object car;</div>
<div class="line">    error = car_value.get_object().get(car);</div>
<div class="line">    if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return false; }</div>
<div class="line"> </div>
<div class="line">    // Accessing a field by name</div>
<div class="line">    std::string_view make;</div>
<div class="line">    std::string_view model;</div>
<div class="line">    error = car[&quot;make&quot;].get(make);</div>
<div class="line">    if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return false; }</div>
<div class="line">    error = car[&quot;model&quot;].get(model);</div>
<div class="line">    if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return false; }</div>
<div class="line"> </div>
<div class="line">    cout &lt;&lt; &quot;Make/Model: &quot; &lt;&lt; make &lt;&lt; &quot;/&quot; &lt;&lt; model &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    // Casting a JSON element to an integer</div>
<div class="line">    uint64_t year;</div>
<div class="line">    error = car[&quot;year&quot;].get(year);</div>
<div class="line">    if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return false; }</div>
<div class="line">    cout &lt;&lt; &quot;- This car is &quot; &lt;&lt; 2020 - year &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">    // Iterating through an array of floats</div>
<div class="line">    double total_tire_pressure = 0;</div>
<div class="line">    ondemand::array pressures;</div>
<div class="line">    error = car[&quot;tire_pressure&quot;].get_array().get(pressures);</div>
<div class="line">    if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return false; }</div>
<div class="line">    for (auto tire_pressure_value : pressures) {</div>
<div class="line">      double tire_pressure;</div>
<div class="line">      error = tire_pressure_value.get_double().get(tire_pressure);</div>
<div class="line">      if(error) { std::cerr &lt;&lt; error &lt;&lt; std::endl; return false; }</div>
<div class="line">      total_tire_pressure += tire_pressure;</div>
<div class="line">    }</div>
<div class="line">    cout &lt;&lt; &quot;- Average tire pressure: &quot; &lt;&lt; (total_tire_pressure / 4) &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">  return true;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following examples illustrates how to iterate through the content of an object without having to handle exceptions. </p><div class="fragment"><div class="line">{c++}</div>
<div class="line"> auto json = R&quot;({&quot;k\u0065y&quot;: 1})&quot;_padded;</div>
<div class="line"> ondemand::parser parser;</div>
<div class="line"> ondemand::document doc;</div>
<div class="line"> auto error = parser.iterate(json).get(doc);</div>
<div class="line"> if(error) { return false; }</div>
<div class="line"> ondemand::object object;</div>
<div class="line"> error = doc.get_object().get(object);</div>
<div class="line"> if(error) { return false; }</div>
<div class="line"> for(auto field : object) {</div>
<div class="line">   ondemand::raw_json_string keyv;</div>
<div class="line">   error = field.key().get(keyv);</div>
<div class="line">   if(error) { return false; }</div>
<div class="line">   if(keyv == &quot;key&quot;) {</div>
<div class="line">     uint64_t intvalue;</div>
<div class="line">     error = field.value().get(intvalue);</div>
<div class="line">     if(error) { return false; }</div>
<div class="line">     std::cout &lt;&lt; intvalue;</div>
<div class="line">   }</div>
<div class="line"> }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Disabling Exceptions</h2>
<p>The simdjson can be build with exceptions entirely disabled. It checks the <code>__cpp_exceptions</code> macro at compile time. Even if exceptions are enabled in your compiler, you may still disable exceptions specifically for simdjson, by setting <code>SIMDJSON_EXCEPTIONS</code> to <code>0</code> (false) at compile-time when building the simdjson library. If you are building with CMake, to ensure you don't write any code that uses exceptions, you compile with <code>SIMDJSON_EXCEPTIONS=OFF</code>. For example, if including the project via cmake:</p>
<div class="fragment"><div class="line">target_compile_definitions(simdjson PUBLIC SIMDJSON_EXCEPTIONS=OFF)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Exceptions</h2>
<p>Users more comfortable with an exception flow may choose to directly cast the <code>simdjson_result&lt;T&gt;</code> to the desired type:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">simdjson::ondemande::document doc = parser.iterate(json); // Throws an exception if there was an error!</div>
</div><!-- fragment --><p>When used this way, a <code>simdjson_error</code> exception will be thrown if an error occurs, preventing the program from continuing if there was an error.</p>
<p>If one is willing to trigger exceptions, it is possible to write simpler code:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;simdjson.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">  simdjson::ondemand::parser parser;</div>
<div class="line">  padded_string json = padded_string::load(&quot;twitter.json&quot;);</div>
<div class="line">  simdjson::ondemand::document tweets = parser.iterate(json);</div>
<div class="line">  uint64_t identifier = tweets[&quot;statuses&quot;].at(0)[&quot;id&quot;];</div>
<div class="line">  std::cout &lt;&lt; identifier &lt;&lt; std::endl;</div>
<div class="line">  return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Current location in document</h2>
<p>Sometimes, it might be helpful to know the current location in the document during iteration. This is especially useful when encountering errors. The <code>current_location()</code> method on a <code>document</code> instances makes it easy to identify common JSON errors. Users can call the <code>current_location()</code> method on a validdocument instance to retrieve a <code>const char *</code> pointer to the current location in the document. This method also works even after an error has invalidated the document and the parser (e.g. <code>TAPE_ERROR</code>, <code>INCOMPLETE_ARRAY_OR_OBJECT</code>). When the input was a <code>padding_string</code> or another null-terminated source, then you may use the <code>const char *</code> pointer as a C string. As an example, consider the following example where we used the exception-free simdjson interface:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto broken_json = R&quot;( {&quot;double&quot;: 13.06, false, &quot;integer&quot;: -343} )&quot;_padded;    // Missing key</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(broken_json);</div>
<div class="line">int64_t i;</div>
<div class="line">auto error = doc[&quot;integer&quot;].get_int64().get(i);    // Expect to get integer from &quot;integer&quot; key, but get TAPE_ERROR</div>
<div class="line">if (error) {</div>
<div class="line">  std::cout &lt;&lt; error &lt;&lt; std::endl;    // Prints TAPE_ERROR error message</div>
<div class="line">  std::cout&lt;&lt; doc.current_location() &lt;&lt; std::endl;  // Prints &quot;false, &quot;integer&quot;: -343} &quot; (location of TAPE_ERROR)</div>
<div class="line">}</div>
</div><!-- fragment --><p>You may also use <code>current_location()</code> with exceptions as follows:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto broken_json = R&quot;( {&quot;double&quot;: 13.06, false, &quot;integer&quot;: -343} )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">ondemand::document doc = parser.iterate(broken_json);</div>
<div class="line">try {</div>
<div class="line">  return int64_t(doc[&quot;integer&quot;]);</div>
<div class="line">} catch(simdjson_error&amp; err) {</div>
<div class="line">  std::cerr &lt;&lt; doc.current_location() &lt;&lt; std::endl;</div>
<div class="line">  return -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In these examples, we tried to access the <code>"integer"</code> key, but since the parser had to go through a value without a key before (<code>false</code>), a <code>TAPE_ERROR</code> error is thrown. The pointer returned by the <code>current_location()</code> method then points at the location of the error. The <code>current_location()</code> may also be used when the error is triggered by a user action, even if the JSON input is valid. Consider the following example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto json = R&quot;( [1,2,3] )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">int64_t i;</div>
<div class="line">auto error = doc[&quot;integer&quot;].get_int64().get(i);    // Incorrect call on array, INCORRECT_TYPE error</div>
<div class="line">if (error) {</div>
<div class="line">  std::cout &lt;&lt; error &lt;&lt; std::endl;     // Prints INCORRECT_TYPE error message</div>
<div class="line">  std::cout&lt;&lt; doc.current_location() &lt;&lt; std::endl;  // Prints &quot;[1,2,3] &quot; (location of INCORRECT_TYPE error)</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the location is invalid (i.e. at the end of a document), the <code>current_location()</code> methods returns an <code>OUT_OF_BOUNDS</code> error. For example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto json = R&quot;( [1,2,3] )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">for (auto val : doc) {</div>
<div class="line">  // Do something with val</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; doc.current_location() &lt;&lt; std::endl;   // Throws OUT_OF_BOUNDS</div>
</div><!-- fragment --><p>Finally, the <code>current_location()</code> method may also be used even when no exceptions/errors are thrown. This can be helpful for users that want to know the current state of iteration during parsing. For example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto json = R&quot;( [[1,2,3], -23.4, {&quot;key&quot;: &quot;value&quot;}, true] )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">for (auto val : doc) {</div>
<div class="line">  ondemand::object obj;</div>
<div class="line">  auto error = val.get_object().get(obj);     // Only get objects</div>
<div class="line">  if (!error) {</div>
<div class="line">    std::cout &lt;&lt; doc.current_location() &lt;&lt; std::endl;   // Prints &quot;&quot;key&quot;: &quot;value&quot;}, true] &quot;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>current_location()</code> method requires a valid <code>document</code> instance. If the <code>iterate</code> function fails to return a valid document, then you cannot use <code>current_location()</code> to identify the location of an error in the input string. The errors reported by <code>iterate</code> function include EMPTY if no JSON document is detected, UTF8_ERROR if the string is not a valid UTF-8 string, UNESCAPED_CHARS if a string contains control characters that must be escaped and UNCLOSED_STRING if there is an unclosed string in the document. We do not provide location information for these errors.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Rewinding</h1>
<p>In some instances, you may need to go through a document more than once. For that purpose, you may call the <code>rewind()</code> method on the document instance. It allows you to restart processing from the beginning without rescanning all of the input data again. It invalidates all values, objects and arrays that you have created so far (including unescaped strings).</p>
<p>In the following example, we print on the screen the number of cars in the JSON input file before printout the data.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> ondemand::parser parser;</div>
<div class="line"> auto cars_json = R&quot;( [</div>
<div class="line">   { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Camry&quot;,  &quot;year&quot;: 2018, &quot;tire_pressure&quot;: [ 40.1, 39.9, 37.7, 40.4 ] },</div>
<div class="line">   { &quot;make&quot;: &quot;Kia&quot;,    &quot;model&quot;: &quot;Soul&quot;,   &quot;year&quot;: 2012, &quot;tire_pressure&quot;: [ 30.1, 31.0, 28.6, 28.7 ] },</div>
<div class="line">   { &quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Tercel&quot;, &quot;year&quot;: 1999, &quot;tire_pressure&quot;: [ 29.8, 30.0, 30.2, 30.5 ] }</div>
<div class="line"> ] )&quot;_padded;</div>
<div class="line"> </div>
<div class="line"> auto doc = parser.iterate(cars_json);</div>
<div class="line"> for (simdjson_unused ondemand::object car : doc) {</div>
<div class="line">   if(car[&quot;make&quot;] == &quot;Toyota&quot;) { count++; }</div>
<div class="line"> }</div>
<div class="line"> std::cout &lt;&lt; &quot;We have &quot; &lt;&lt; count &lt;&lt; &quot; Toyota cars.\n&quot;;</div>
<div class="line"> doc.rewind(); // requires simdjson 1.0 or better</div>
<div class="line"> for (ondemand::object car : doc) {</div>
<div class="line">   cout &lt;&lt; &quot;Make/Model: &quot; &lt;&lt; std::string_view(car[&quot;make&quot;]) &lt;&lt; &quot;/&quot; &lt;&lt; std::string_view(car[&quot;model&quot;]) &lt;&lt; endl;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Performance note: the On Demand front-end does not materialize the parsed numbers and other values. If you are accessing everything twice, you may need to parse them twice. Thus the rewind functionality is best suited for cases where the first pass only scans the structure of the document.</p>
<p>Both arrays and objects have a similar method <code>reset()</code>. It is similar to the document <code>rewind()</code> method, except that it does not rewind the internal string buffer. Thus you should consume values only once even if you can iterate through the array or object more than once. If you unescape a string within an array more than once, you have unsafe code.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Direct Access to the Raw String</h1>
<p>The simdjson library makes explicit assumptions about types. For examples, numbers must be integers (up to 64-bit integers) or binary64 floating-point numbers. Some users have different needs. For example, some users might want to support big infloating-point number followed by an integer.tegers. The library makes this possible by providing a <code>raw_json_token</code> method which returns a <code>std::string_view</code> instance containing the value as a string which you may then parse as you see fit.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">simdjson::ondemand::parser parser;</div>
<div class="line">simdjson::padded_string docdata =  R&quot;({&quot;value&quot;:12321323213213213213213213213211223})&quot;_padded;</div>
<div class="line">simdjson::ondemand::document doc = parser.iterate(docdata);</div>
<div class="line">simdjson::ondemand::object obj = doc.get_object();</div>
<div class="line">std::string_view token = obj[&quot;value&quot;].raw_json_token();</div>
<div class="line">// token has value 12321323213213213213213213213211223, it points inside the input string</div>
</div><!-- fragment --><p>The <code>raw_json_token</code> method even works when the JSON value is a string. In such cases, it will return the complete string with the quotes and with eventual escaped sequences as in the source document.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">simdjson::ondemand::parser parser;</div>
<div class="line">simdjson::padded_string docdata =  R&quot;({&quot;value&quot;:&quot;12321323213213213213213213213211223&quot;})&quot;_padded;</div>
<div class="line">simdjson::ondemand::document doc = parser.iterate(docdata);</div>
<div class="line">simdjson::ondemand::object obj = doc.get_object();</div>
<div class="line">string_view token = obj[&quot;value&quot;].raw_json_token();</div>
<div class="line">// token has value &quot;12321323213213213213213213213211223&quot;, it points inside the input string</div>
</div><!-- fragment --><p>The <code>raw_json_token()</code> should be fast and free of allocation.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Newline-Delimited JSON (ndjson) and JSON lines</h1>
<p>The simdjson library also supports multithreaded JSON streaming through a large file containing many smaller JSON documents in either <a href="http://ndjson.org">ndjson</a> or <a href="http://jsonlines.org">JSON lines</a> format. If your JSON documents all contain arrays or objects, we even support direct file concatenation without whitespace. The concatenated file has no size restrictions (including larger than 4GB), though each individual document must be no larger than 4 GB.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto json = R&quot;({ &quot;foo&quot;: 1 } { &quot;foo&quot;: 2 } { &quot;foo&quot;: 3 } )&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">ondemand::document_stream docs = parser.iterate_many(json);</div>
<div class="line">for (auto doc : docs) {</div>
<div class="line">  std::cout &lt;&lt; doc[&quot;foo&quot;] &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">// Prints 1 2 3</div>
</div><!-- fragment --><p>Unlike <code>parser.iterate</code>, <code>parser.iterate_many</code> may parse "on demand" (lazily). That is, no parsing may have been done before you enter the loop <code>for (auto doc : docs) {</code> and you should expect the parser to only ever fully parse one JSON document at a time.</p>
<p>As with <code>parser.iterate</code>, when calling <code>parser.iterate_many(string)</code>, no copy is made of the provided string input. The provided memory buffer may be accessed each time a JSON document is parsed. Calling <code>parser.iterate_many(string)</code> on a temporary string buffer (e.g., <code>docs = parser.parse_many("[1,2,3]"_padded)</code>) is unsafe (and will not compile) because the <code>document_stream</code> instance needs access to the buffer to return the JSON documents.</p>
<p>The <code>iterate_many</code> function can also take an optional parameter <code>size_t batch_size</code> which defines the window processing size. It is set by default to a large value (<code>1000000</code> corresponding to 1 MB). None of your JSON documents should exceed this window size, or else you will get the error <code>simdjson::CAPACITY</code>. You cannot set this window size larger than 4 GB: you will get the error <code>simdjson::CAPACITY</code>. The smaller the window size is, the less memory the function will use. Setting the window size too small (e.g., less than 100 kB) may also impact performance negatively. Leaving it to 1 MB is expected to be a good choice, unless you have some larger documents.</p>
<p>The following toy examples illustrates how to get capacity errors. It is an artificial example since you should never use a <code>batch_size</code> of 50 bytes (it is far too small).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// We are going to set the capacity to 50 bytes which means that we cannot</div>
<div class="line">// loading a document longer than 50 bytes. The first few documents are small,</div>
<div class="line">// but the last one is large. We will get an error at the last document.</div>
<div class="line">auto json = R&quot;([1,2,3,4,5] [1,2,3,4,5] [1,2,3,4,5] [1,2,3,4,5] [1,2,3,4,5] [1,2,3,4,5] [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100])&quot;_padded;</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">ondemand::document_stream stream;</div>
<div class="line">size_t counter{0};</div>
<div class="line">auto error = parser.iterate_many(json, 50).get(stream);</div>
<div class="line">if( error ) { /* handle the error */ }</div>
<div class="line">for (auto doc: stream) {</div>
<div class="line">  if(counter &lt; 6) {</div>
<div class="line">    int64_t val;</div>
<div class="line">    error = doc.at_pointer(&quot;/4&quot;).get(val);</div>
<div class="line">    if( error ) { /* handle the error */ }</div>
<div class="line">    std::cout &lt;&lt; &quot;5 = &quot; &lt;&lt; val &lt;&lt; std::endl;</div>
<div class="line">  } else {</div>
<div class="line">    ondemand::value val;</div>
<div class="line">    error = doc.at_pointer(&quot;/4&quot;).get(val);</div>
<div class="line">    // error == simdjson::CAPACITY</div>
<div class="line">    if(error) {</div>
<div class="line">      std::cerr &lt;&lt; error &lt;&lt; std::endl;</div>
<div class="line">      // We left 293 bytes unprocessed at the tail end of the input.</div>
<div class="line">      std::cout &lt;&lt; &quot; unprocessed bytes at the end: &quot; &lt;&lt; stream.truncated_bytes() &lt;&lt; std::endl;</div>
<div class="line">      break;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  counter++;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example should print out:</p>
<div class="fragment"><div class="line">5 = 5</div>
<div class="line">5 = 5</div>
<div class="line">5 = 5</div>
<div class="line">5 = 5</div>
<div class="line">5 = 5</div>
<div class="line">5 = 5</div>
<div class="line">This parser can&#39;t support a document that big</div>
<div class="line"> unprocessed bytes at the end: 293</div>
</div><!-- fragment --><p>If your documents are large (e.g., larger than a megabyte), then the <code>iterate_many</code> function is maybe ill-suited. It is really meant to support reading efficiently streams of relatively small documents (e.g., a few kilobytes each). If you have larger documents, you should use other functions like <code>iterate</code>.</p>
<p>See <a class="el" href="md_doc_iterate_many.html">iterate_many.md</a> for detailed information and design.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Parsing Numbers Inside Strings</h1>
<p>Though the JSON specification allows for numbers and string values, many engineers choose to integrate the numbers inside strings, e.g., they prefer <code>{"a":"1.9"}</code> to<code>{"a":1.9}</code>. The simdjson library supports parsing valid numbers inside strings which makes it more convenient for people working with those types of documents. This feature is supported through three methods: <code>get_double_in_string</code>, <code>get_int64_in_string</code> and <code>get_uint64_in_string</code>. However, it is important to note that these methods are not substitute to the regular <code>get_double</code>, <code>get_int64</code> and <code>get_uint64</code>. The usage of the <code>get_*_in_string</code> methods is solely to parse valid JSON numbers inside strings, and so we expect users to call these methods appropriately. In particular, a valid JSON number has no leading and no trailing whitespaces, and the strings <code>"nan"</code>, <code>"1e"</code> and <code>"infinity"</code> will not be accepted as valid numbers. As an example, suppose we have the following JSON text:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto json =</div>
<div class="line">{</div>
<div class="line">   &quot;ticker&quot;:{</div>
<div class="line">      &quot;base&quot;:&quot;BTC&quot;,</div>
<div class="line">      &quot;target&quot;:&quot;USD&quot;,</div>
<div class="line">      &quot;price&quot;:&quot;443.7807865468&quot;,</div>
<div class="line">      &quot;volume&quot;:&quot;31720.1493969300&quot;,</div>
<div class="line">      &quot;change&quot;:&quot;Infinity&quot;,</div>
<div class="line">      &quot;markets&quot;:[</div>
<div class="line">         {</div>
<div class="line">            &quot;market&quot;:&quot;bitfinex&quot;,</div>
<div class="line">            &quot;price&quot;:&quot;447.5000000000&quot;,</div>
<div class="line">            &quot;volume&quot;:&quot;10559.5293639000&quot;</div>
<div class="line">         },</div>
<div class="line">         {</div>
<div class="line">            &quot;market&quot;:&quot;bitstamp&quot;,</div>
<div class="line">            &quot;price&quot;:&quot;448.5400000000&quot;,</div>
<div class="line">            &quot;volume&quot;:&quot;11628.2880079300&quot;</div>
<div class="line">         },</div>
<div class="line">         {</div>
<div class="line">            &quot;market&quot;:&quot;btce&quot;,</div>
<div class="line">            &quot;price&quot;:&quot;432.8900000000&quot;,</div>
<div class="line">            &quot;volume&quot;:&quot;8561.0563600000&quot;</div>
<div class="line">         }</div>
<div class="line">      ]</div>
<div class="line">   },</div>
<div class="line">   &quot;timestamp&quot;:1399490941,</div>
<div class="line">   &quot;timestampstr&quot;:&quot;1399490941&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, suppose that a user wants to get the time stamp from the <code>timestampstr</code> key. One could do the following:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">uint64_t time = doc.at_pointer(&quot;/timestampstr&quot;).get_uint64_in_string();</div>
<div class="line">std::cout &lt;&lt; time &lt;&lt; std::endl;   // Prints 1399490941</div>
</div><!-- fragment --><p>Another thing a user might want to do is extract the <code>markets</code> array and get the market name, price and volume. Here is one way to do so:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line"> </div>
<div class="line">// Getting markets array</div>
<div class="line">ondemand::array markets = doc.find_field(&quot;ticker&quot;).find_field(&quot;markets&quot;).get_array();</div>
<div class="line">// Iterating through markets array</div>
<div class="line">for (auto value : markets) {</div>
<div class="line">    std::cout &lt;&lt; &quot;Market: &quot; &lt;&lt; value.find_field(&quot;market&quot;).get_string();</div>
<div class="line">    std::cout &lt;&lt; &quot;\tPrice: &quot; &lt;&lt; value.find_field(&quot;price&quot;).get_double_in_string();</div>
<div class="line">    std::cout &lt;&lt; &quot;\tVolume: &quot; &lt;&lt; value.find_field(&quot;volume&quot;).get_double_in_string() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/* The above prints</div>
<div class="line">Market: bitfinex        Price: 447.5    Volume: 10559.5</div>
<div class="line">Market: bitstamp        Price: 448.54   Volume: 11628.3</div>
<div class="line">Market: btce    Price: 432.89   Volume: 8561.06</div>
<div class="line">*/</div>
</div><!-- fragment --><p>Finally, here is an example dealing with errors where the user wants to convert the string <code>"Infinity"</code>(<code>"change"</code> key) to a float with infinity value.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ondemand::parser parser;</div>
<div class="line">auto doc = parser.iterate(json);</div>
<div class="line">// Get &quot;change&quot;/&quot;Infinity&quot; key/value pair</div>
<div class="line">ondemand::value value = doc.find_field(&quot;ticker&quot;).find_field(&quot;change&quot;);</div>
<div class="line">double d;</div>
<div class="line">std::string_view view;</div>
<div class="line">auto error = value.get_double_in_string().get(d);</div>
<div class="line">// Check if parsed value into double successfully</div>
<div class="line">if (error) {</div>
<div class="line">  error = value.get_string().get(view);</div>
<div class="line">  if (error) { /* Handle error */ }</div>
<div class="line">  else if (view == &quot;Infinity&quot;) {</div>
<div class="line">    d = std::numeric_limits::infinity();</div>
<div class="line">  }</div>
<div class="line">  else { /* Handle wrong value */ }</div>
<div class="line">}</div>
</div><!-- fragment --><p> It is also important to note that when dealing an invalid number inside a string, simdjson will report a <code>NUMBER_ERROR</code> error if the string begins with a number whereas simdjson will report a <code>INCORRECT_TYPE</code> error otherwise.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Dynamic Number Types</h1>
<p>The JSON standard does not offer strongly typed numbers. It suggests that using the binary64 type (<code>double</code> in C++) is a safe choice, but little else. Given the JSON array <code>[1.0,1]</code>, it is not specified whether it is an array of two floating-point numbers, two integers, or one floating-point number followed by an integer.</p>
<p>Given an <code>ondemand::value</code> instance, you may ask whether it is a negative value with the <code>is_negative()</code> method. The function is inexpensive.</p>
<p>To occasionally distinguish between floating-point values and integers given an <code>ondemand::value</code> instance, you may call the <code>is_integer()</code> method. We recognize an integer number by the lack decimal point and the lack of exponential suffix. E.g., <code>1e1</code> is always considered to be a floating-point number. The <code>is_integer()</code> method does not consume the value, but it scans the number string. You should avoid calling it repeatedly.</p>
<p>If you need to determine both the type of the number (integer or floating-point) and its value efficiently, you may call the <code>get_number()</code> method on the <code>ondemand::value</code> instance. Upon success, it returns an <code>ondemand::number</code> instance.</p>
<p>An <code>ondemand::number</code> instance may contain an integer value or a floating-point value. Thus it is a dynamically typed number. Before accessing the value, you must determine the detected type:</p>
<ul>
<li><code>number.get_number_type()</code> has value <code>number_type::signed_integer</code> if we have a integer in [-9223372036854775808,9223372036854775808). You can recover the value by the <code>get_int64()</code> method applied on the <code>ondemand::number</code> instance. When <code>number.get_number_type()</code> has value <code>number_type::signed_integer</code>, you also have that <code>number.is_int64()</code> is true. Calling <code>get_int64()</code> on the <code>ondemand::number</code> instance when <code>number.get_number_type()</code> is not <code>number_type::signed_integer</code> is unsafe. You may replace <code>get_int64()</code> by a cast to a <code>int64_t</code> value.</li>
<li><code>number.get_number_type()</code> has value <code>number_type::unsigned_integer</code> if we have a integer in [9223372036854775808,18446744073709551616). You can recover the value by the <code>get_uint64()</code> method applied on the <code>ondemand::number</code> instance. When <code>number.get_number_type()</code> has value <code>number_type::unsigned_integer</code>, you also have that <code>number.is_uint64()</code> is true. Calling <code>get_uint64()</code> on the <code>ondemand::number</code> instance when <code>number.get_number_type()</code> is not <code>number_type::unsigned_integer</code> is unsafe. You may replace <code>get_uint64()</code> by a cast to a <code>uint64_t</code> value.</li>
<li><code>number.get_number_type()</code> has value <code>number_type::floating_point_number</code> if we have and we have a floating-point (binary64) number. You can recover the value by the <code>get_double()</code> method applied on the <code>ondemand::number</code> instance. When <code>number.get_number_type()</code> has value <code>number_type::floating_point_number</code>, you also have that <code>number.is_double()</code> is true. Calling <code>get_double()</code> on the <code>ondemand::number</code> instance when <code>number.get_number_type()</code> is not <code>number_type::floating_point_number</code> is unsafe. You may replace <code>get_double()</code> by a cast to a <code>double</code> value.</li>
</ul>
<p>You must check the type before accessing the value: it is an error to call <code>get_int64()</code> when <code>number.get_number_type()</code> is not <code>number_type::signed_integer</code> and when <code>number.is_int64()</code> is false. You are responsible for this check as the user of the library.</p>
<p>The <code>get_number()</code> function is designed with performance in mind. When calling <code>get_number()</code>, you scan the number string only once, determining efficiently the type and storing it in an efficient manner.</p>
<p>If you only need to compute <code>v.get_number().get_number_type()</code> on a <code>document</code> or <code>value</code> instance, you should call directly the faster method <code>v.get_number_type()</code> which does not generate an intermediate <code>number</code> instance.</p>
<p>Consider the following example: </p><div class="fragment"><div class="line">{C++}</div>
<div class="line">   ondemand::parser parser;</div>
<div class="line">   padded_string docdata = R&quot;([1.0, 3, 1, 3.1415,-13231232,9999999999999999999])&quot;_padded;</div>
<div class="line">   ondemand::document doc = parser.iterate(docdata);</div>
<div class="line">   ondemand::array arr = doc.get_array();</div>
<div class="line">   for(ondemand::value val : arr) {</div>
<div class="line">     std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;</div>
<div class="line">     std::cout &lt;&lt; &quot;negative: &quot; &lt;&lt; val.is_negative() &lt;&lt; &quot; &quot;;</div>
<div class="line">     std::cout &lt;&lt; &quot;is_integer: &quot; &lt;&lt; val.is_integer() &lt;&lt; &quot; &quot;;</div>
<div class="line">     ondemand::number num = val.get_number();</div>
<div class="line">     // direct computation without materializing the number:</div>
<div class="line">     ondemand::number_type dt = val.get_number_type();</div>
<div class="line">     if(t != dt) { throw std::runtime_error(&quot;bug&quot;); }</div>
<div class="line">     switch(t) {</div>
<div class="line">       case ondemand::number_type::signed_integer:</div>
<div class="line">         std::cout  &lt;&lt; &quot;integer: &quot; &lt;&lt; int64_t(num) &lt;&lt; &quot; &quot;;</div>
<div class="line">         std::cout  &lt;&lt; &quot;integer: &quot; &lt;&lt; num.get_int64() &lt;&lt; std::endl;</div>
<div class="line">         break;</div>
<div class="line">       case ondemand::number_type::unsigned_integer:</div>
<div class="line">         std::cout  &lt;&lt; &quot;large 64-bit integer: &quot; &lt;&lt; uint64_t(num) &lt;&lt; &quot; &quot;;</div>
<div class="line">         std::cout &lt;&lt; &quot;large 64-bit integer: &quot; &lt;&lt; num.get_uint64() &lt;&lt; std::endl;</div>
<div class="line">         break;</div>
<div class="line">       case ondemand::number_type::floating_point_number:</div>
<div class="line">         std::cout  &lt;&lt; &quot;float: &quot; &lt;&lt; double(num) &lt;&lt; &quot; &quot;;</div>
<div class="line">         std::cout &lt;&lt; &quot;float: &quot; &lt;&lt; num.get_double() &lt;&lt; std::endl;</div>
<div class="line">         break;</div>
<div class="line">     }</div>
<div class="line">   }</div>
</div><!-- fragment --><p>It will output:</p>
<div class="fragment"><div class="line">1.0 negative: 0 is_integer: 0 float: 1 float: 1</div>
<div class="line">3 negative: 0 is_integer: 1 integer: 3 integer: 3</div>
<div class="line">1 negative: 0 is_integer: 1 integer: 1 integer: 1</div>
<div class="line">3.1415 negative: 0 is_integer: 0 float: 3.1415 float: 3.1415</div>
<div class="line">-13231232 negative: 1 is_integer: 1 integer: -13231232 integer: -13231232</div>
<div class="line">9999999999999999999 negative: 0 is_integer: 1 large 64-bit integer: 9999999999999999999 large 64-bit integer: 9999999999999999999</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md24"></a>
Thread Safety</h1>
<p>We built simdjson with thread safety in mind.</p>
<p>The simdjson library is single-threaded except for <a class="el" href="md_doc_iterate_many.html">`iterate_many`</a> and <a class="el" href="md_doc_parse_many.html">`parse_many`</a> which may use secondary threads under their control when the library is compiled with thread support.</p>
<p>We recommend using one <code>parser</code> object per thread. When using the On Demand front-end (our default), you should access the <code>document</code> instances in a single-threaded manner since it acts as an iterator (and is therefore not thread safe).</p>
<p>The CPU detection, which runs the first time parsing is attempted and switches to the fastest parser for your CPU, is transparent and thread-safe.</p>
<p>In a threaded environment, stack space is often limited. Running code like simdjson in debug mode may require hundreds of kilobytes of stack memory. Thus stack overflows are a possibility. We recommend you turn on optimization when working in an environment where stack space is limited. If you must run your code in debug mode, we recommend you configure your system to have more stack space. We discourage you from running production code based on a debug build.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Standard Compliance</h1>
<p>The simdjson library is fully compliant with the <a href="https://www.tbray.org/ongoing/When/201x/2017/12/14/rfc8259.html">RFC 8259</a> JSON specification.</p>
<ul>
<li>The only insignificant whitespace characters allowed are the space, the horizontal tab, the line feed and the carriage return. In particular, a JSON document may not contain an unespaced null character.</li>
<li>A single string or a single number is considered to be a valid JSON document.</li>
<li>We fully validate the numbers according to the JSON specification. For example, the string <code>01</code> is not valid JSON document since the specification states that <em>leading zeros are not allowed</em>.</li>
<li>The specification allows implementations to set limits on the range and precision of numbers accepted. We support 64-bit floating-point numbers as well as integer values.<ul>
<li>We parse integers and floating-point numbers afloating-point number followed by an integer.s separate types which allows us to support all signed (two's complement) 64-bit integersfloating-point number followed by an integer., like a Java <code>long</code> or a C/C++ <code>long long</code> and all 64-bit unsigned integers. When we cannot represent exactly an integer as a signed or unsigned 64-bit value, we reject the JSON document.</li>
<li>We support the full range of 64-bit floating-point numbers (binary64). The values range from <code>std::numeric_limits&lt;double&gt;::lowest()</code> to <code>std::numefloating-point number followed by an integer.ric_limits&lt;double&gt;::max()</code>, so from -1.7976e308 all the way to 1.7975e308. Extreme values (less or equal to -1e308, greater or equal to 1e308) are rejected: we refuse to parse the input document. Numbers are parsed with a perfect accuracy (ULP 0): the nearest floating-point value is chosen, rounding to even when needed. If you serialized your floating-point numbers with 17floating-point value followed by an integer. significant digits in a standard compliant manner, the simdjson library is guaranfloating-point number followed by an integer.teed to recover the same numbers, exactly.</li>
</ul>
</li>
<li>The specification states that JSON text exchanged between systems that are not part of a closed ecosystem MUST be encoded using UTF-8. The simdjson library does full UTF-8 validation as part of the parsing. The specification states that implementations MUST NOT add a byte order mark: the simdjson library rejects documents starting with a byte order mark.</li>
<li>The simdjson library validates string content for unescaped characters. Unescaped line breaks and tabs in strings are not allowed.</li>
<li>The simdjson library accepts objects with repeated keys: all of the name/value pairs, including duplicates, are reported. We do not enforce key uniqueness.</li>
<li>The specification states that an implementation may set limits on the size of texts that it accepts. The simdjson library limits single JSON documents to 4 GiB. It will refuse to parse a JSON document larger than 4294967295 bytes. (This limitation does not apply to streams of JSON documents, only to single JSON documents.)</li>
<li>The specification states that an implementation may set limits on the maximum depth of nesting. By default, the simdjson will refuse to parse documents with a depth exceeding 1024.</li>
</ul>
<h1><a class="anchor" id="autotoc_md26"></a>
Backwards Compatibility</h1>
<p>The only header file supported by simdjson is <code>simdjson.h</code>. Older versions of simdjson published a number of other include files such as <code>document.h</code> or <code><a class="el" href="parsedjson_8h_source.html">ParsedJson.h</a></code> alongside <code>simdjson.h</code>; these headers may be moved or removed in future versions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
