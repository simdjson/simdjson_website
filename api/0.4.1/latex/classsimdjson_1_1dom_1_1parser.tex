\hypertarget{classsimdjson_1_1dom_1_1parser}{}\doxysection{simdjson\+::dom\+::parser Class Reference}
\label{classsimdjson_1_1dom_1_1parser}\index{simdjson::dom::parser@{simdjson::dom::parser}}


A persistent document parser.  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
really\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a6d42a72d1dcdac2149a40e0d5f93ddeb}{parser}} (size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a6b68d9202cd9aa595c2c505e09deb2b2}{max\+\_\+capacity}}=S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+M\+A\+X\+S\+I\+Z\+E\+\_\+\+B\+Y\+T\+ES) noexcept
\begin{DoxyCompactList}\small\item\em Create a J\+S\+ON parser. \end{DoxyCompactList}\item 
really\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a98a56b6363c97c78b68573a47f21ee38}{parser}} (\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{parser}} \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Take another parser\textquotesingle{}s buffers and state. \end{DoxyCompactList}\item 
really\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{parser}} \& \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a778a9b5712f29638cf1fb3670278f4c6}{operator=}} (\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{parser}} \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em Take another parser\textquotesingle{}s buffers and state. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_aeb48211f320af02b58dc3d0505059844}\label{classsimdjson_1_1dom_1_1parser_aeb48211f320af02b58dc3d0505059844}} 
\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_aeb48211f320af02b58dc3d0505059844}{$\sim$parser}} ()=default
\begin{DoxyCompactList}\small\item\em Deallocate the J\+S\+ON parser. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_ab3e5bbb1974a1932aead90ad63883a23}{load}} (const std\+::string \&path) \&noexcept
\begin{DoxyCompactList}\small\item\em Load a J\+S\+ON document from a file and return a reference to it. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a6b460c66661f1145d454b53c7ef5f514}\label{classsimdjson_1_1dom_1_1parser_a6b460c66661f1145d454b53c7ef5f514}} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries load} (const std\+::string \&path) \&\&=delete
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a16c7d1e28125ef7d5703244483f70984}{parse}} (const uint8\+\_\+t $\ast$buf, size\+\_\+t len, bool realloc\+\_\+if\+\_\+needed=true) \&noexcept
\begin{DoxyCompactList}\small\item\em Parse a J\+S\+ON document and return a temporary reference to it. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_ae00a3050513990e4ea4a03ea21eb8e74}\label{classsimdjson_1_1dom_1_1parser_ae00a3050513990e4ea4a03ea21eb8e74}} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries parse} (const uint8\+\_\+t $\ast$buf, size\+\_\+t len, bool realloc\+\_\+if\+\_\+needed=true) \&\&=delete
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a85109f597ed9086bda0b853a33afe7d2}\label{classsimdjson_1_1dom_1_1parser_a85109f597ed9086bda0b853a33afe7d2}} 
really\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries parse} (const char $\ast$buf, size\+\_\+t len, bool realloc\+\_\+if\+\_\+needed=true) \&noexcept
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a5cf3ce35e7ff0a94a6038c5edd79dd6e}\label{classsimdjson_1_1dom_1_1parser_a5cf3ce35e7ff0a94a6038c5edd79dd6e}} 
really\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries parse} (const char $\ast$buf, size\+\_\+t len, bool realloc\+\_\+if\+\_\+needed=true) \&\&=delete
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a83539aed8ed03cc3a96e66fa7be4d18a}\label{classsimdjson_1_1dom_1_1parser_a83539aed8ed03cc3a96e66fa7be4d18a}} 
really\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries parse} (const std\+::string \&s) \&noexcept
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_ac6a70a1c6586ff838394ab8870ba1951}\label{classsimdjson_1_1dom_1_1parser_ac6a70a1c6586ff838394ab8870ba1951}} 
really\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries parse} (const std\+::string \&s) \&\&=delete
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a61e1f1b3ee31826d9b358b33cd06d410}\label{classsimdjson_1_1dom_1_1parser_a61e1f1b3ee31826d9b358b33cd06d410}} 
really\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries parse} (const \mbox{\hyperlink{structsimdjson_1_1padded__string}{padded\+\_\+string}} \&s) \&noexcept
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a8f18ca918495941fbaa4d930335b89e8}\label{classsimdjson_1_1dom_1_1parser_a8f18ca918495941fbaa4d930335b89e8}} 
really\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ {\bfseries parse} (const \mbox{\hyperlink{structsimdjson_1_1padded__string}{padded\+\_\+string}} \&s) \&\&=delete
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{document\+\_\+stream}} $>$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_aeb4dda9e15917e22b4679aa2b9cf97ab}{load\+\_\+many}} (const std\+::string \&path, size\+\_\+t batch\+\_\+size=D\+E\+F\+A\+U\+L\+T\+\_\+\+B\+A\+T\+C\+H\+\_\+\+S\+I\+ZE) noexcept
\begin{DoxyCompactList}\small\item\em Load a file containing many J\+S\+ON documents. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{document\+\_\+stream}} $>$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a6bf8c584096b98e6fdbb444e35863113}{parse\+\_\+many}} (const uint8\+\_\+t $\ast$buf, size\+\_\+t len, size\+\_\+t batch\+\_\+size=D\+E\+F\+A\+U\+L\+T\+\_\+\+B\+A\+T\+C\+H\+\_\+\+S\+I\+ZE) noexcept
\begin{DoxyCompactList}\small\item\em Parse a buffer containing many J\+S\+ON documents. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a8f8115094884243210296e75201e1bde}\label{classsimdjson_1_1dom_1_1parser_a8f8115094884243210296e75201e1bde}} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries parse\+\_\+many} (const char $\ast$buf, size\+\_\+t len, size\+\_\+t batch\+\_\+size=D\+E\+F\+A\+U\+L\+T\+\_\+\+B\+A\+T\+C\+H\+\_\+\+S\+I\+ZE) noexcept
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_ad1b6fdd6d3dbba57f7a4bd110d92e6e6}\label{classsimdjson_1_1dom_1_1parser_ad1b6fdd6d3dbba57f7a4bd110d92e6e6}} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries parse\+\_\+many} (const std\+::string \&s, size\+\_\+t batch\+\_\+size=D\+E\+F\+A\+U\+L\+T\+\_\+\+B\+A\+T\+C\+H\+\_\+\+S\+I\+ZE) noexcept
\item 
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a5f1918b205223c3d016608076d71a667}\label{classsimdjson_1_1dom_1_1parser_a5f1918b205223c3d016608076d71a667}} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries parse\+\_\+many} (const \mbox{\hyperlink{structsimdjson_1_1padded__string}{padded\+\_\+string}} \&s, size\+\_\+t batch\+\_\+size=D\+E\+F\+A\+U\+L\+T\+\_\+\+B\+A\+T\+C\+H\+\_\+\+S\+I\+ZE) noexcept
\item 
W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+ED error\+\_\+code \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a9ca2d9dda4cfb61c6a08090c099ed061}{allocate}} (size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a02eaaa274ecdabb4342223da9e6bd8a7}{capacity}}, size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a6a0b970821b8ecb98a0222a9fa4eb57a}{max\+\_\+depth}}=D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+A\+X\+\_\+\+D\+E\+P\+TH) noexcept
\begin{DoxyCompactList}\small\item\em Ensure this parser has enough memory to process J\+S\+ON documents up to {\ttfamily capacity} bytes in length and {\ttfamily max\+\_\+depth} depth. \end{DoxyCompactList}\item 
really\+\_\+inline size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a02eaaa274ecdabb4342223da9e6bd8a7}{capacity}} () const noexcept
\begin{DoxyCompactList}\small\item\em The largest document this parser can support without reallocating. \end{DoxyCompactList}\item 
really\+\_\+inline size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a6b68d9202cd9aa595c2c505e09deb2b2}{max\+\_\+capacity}} () const noexcept
\begin{DoxyCompactList}\small\item\em The largest document this parser can automatically support. \end{DoxyCompactList}\item 
really\+\_\+inline size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a6a0b970821b8ecb98a0222a9fa4eb57a}{max\+\_\+depth}} () const noexcept
\begin{DoxyCompactList}\small\item\em The maximum level of nested object and arrays supported by this parser. \end{DoxyCompactList}\item 
really\+\_\+inline void \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_acbc6d25fb25b52dcafc32c3855ffeb98}{set\+\_\+max\+\_\+capacity}} (size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a6b68d9202cd9aa595c2c505e09deb2b2}{max\+\_\+capacity}}) noexcept
\begin{DoxyCompactList}\small\item\em Set max\+\_\+capacity. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A persistent document parser. 

The parser is designed to be reused, holding the internal buffers necessary to do parsing, as well as memory for a single document. The parsed document is overwritten on each parse.

This class cannot be copied, only moved, to avoid unintended allocations.

\begin{DoxyNote}{Note}
This is not thread safe\+: one parser cannot produce two documents at the same time! 
\end{DoxyNote}


Definition at line 36 of file parser.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a6d42a72d1dcdac2149a40e0d5f93ddeb}\label{classsimdjson_1_1dom_1_1parser_a6d42a72d1dcdac2149a40e0d5f93ddeb}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!parser@{parser}}
\index{parser@{parser}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{parser()}{parser()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily really\+\_\+inline simdjson\+::dom\+::parser\+::parser (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{max\+\_\+capacity = {\ttfamily SIMDJSON\+\_\+MAXSIZE\+\_\+BYTES} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}, {\ttfamily [noexcept]}}



Create a J\+S\+ON parser. 

The new parser will have zero capacity.


\begin{DoxyParams}{Parameters}
{\em max\+\_\+capacity} & The maximum document length the parser can automatically handle. The parser will allocate more capacity on an as needed basis (when it sees documents too big to handle) up to this amount. The parser still starts with zero capacity no matter what this number is\+: to allocate an initial capacity, call \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a9ca2d9dda4cfb61c6a08090c099ed061}{allocate()}} after constructing the parser. Defaults to S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+M\+A\+X\+S\+I\+Z\+E\+\_\+\+B\+Y\+T\+ES (the largest single document simdjson can process). \\
\hline
\end{DoxyParams}


Definition at line 18 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a98a56b6363c97c78b68573a47f21ee38}\label{classsimdjson_1_1dom_1_1parser_a98a56b6363c97c78b68573a47f21ee38}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!parser@{parser}}
\index{parser@{parser}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{parser()}{parser()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily really\+\_\+inline simdjson\+::dom\+::parser\+::parser (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{parser}} \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}



Take another parser\textquotesingle{}s buffers and state. 


\begin{DoxyParams}{Parameters}
{\em other} & The parser to take. Its capacity is zeroed. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a9ca2d9dda4cfb61c6a08090c099ed061}\label{classsimdjson_1_1dom_1_1parser_a9ca2d9dda4cfb61c6a08090c099ed061}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!allocate@{allocate}}
\index{allocate@{allocate}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+ED error\+\_\+code simdjson\+::dom\+::parser\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{capacity,  }\item[{size\+\_\+t}]{max\+\_\+depth = {\ttfamily DEFAULT\+\_\+MAX\+\_\+DEPTH} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Ensure this parser has enough memory to process J\+S\+ON documents up to {\ttfamily capacity} bytes in length and {\ttfamily max\+\_\+depth} depth. 


\begin{DoxyParams}{Parameters}
{\em capacity} & The new capacity. \\
\hline
{\em max\+\_\+depth} & The new max\+\_\+depth. Defaults to D\+E\+F\+A\+U\+L\+T\+\_\+\+M\+A\+X\+\_\+\+D\+E\+P\+TH. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The error, if there is one. 
\end{DoxyReturn}


Definition at line 147 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a02eaaa274ecdabb4342223da9e6bd8a7}\label{classsimdjson_1_1dom_1_1parser_a02eaaa274ecdabb4342223da9e6bd8a7}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!capacity@{capacity}}
\index{capacity@{capacity}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{capacity()}{capacity()}}
{\footnotesize\ttfamily really\+\_\+inline size\+\_\+t simdjson\+::dom\+::parser\+::capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}



The largest document this parser can support without reallocating. 

\begin{DoxyReturn}{Returns}
Current capacity, in bytes. 
\end{DoxyReturn}


Definition at line 136 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_ab3e5bbb1974a1932aead90ad63883a23}\label{classsimdjson_1_1dom_1_1parser_ab3e5bbb1974a1932aead90ad63883a23}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!load@{load}}
\index{load@{load}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{load()}{load()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ simdjson\+::dom\+::parser\+::load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Load a J\+S\+ON document from a file and return a reference to it. 

\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{dom\+::parser}} parser; const element doc = \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_ab3e5bbb1974a1932aead90ad63883a23}{parser.\+load}}(\char`\"{}jsonexamples/twitter.\+json\char`\"{});\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md66}{}\doxyparagraph{I\+M\+P\+O\+R\+T\+A\+N\+T\+: Document Lifetime}\label{classsimdjson_1_1dom_1_1parser_autotoc_md66}
The J\+S\+ON document still lives in the parser\+: this is the most efficient way to parse J\+S\+ON documents because it reuses the same buffers, but you {\itshape must} use the document before you destroy the parser or call \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a16c7d1e28125ef7d5703244483f70984}{parse()}} again.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md67}{}\doxyparagraph{Parser Capacity}\label{classsimdjson_1_1dom_1_1parser_autotoc_md67}
If the parser\textquotesingle{}s current capacity is less than the file length, it will allocate enough capacity to handle it (up to max\+\_\+capacity).


\begin{DoxyParams}{Parameters}
{\em path} & The path to load. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The document, or an error\+:
\begin{DoxyItemize}
\item I\+O\+\_\+\+E\+R\+R\+OR if there was an error opening or reading the file.
\item M\+E\+M\+A\+L\+L\+OC if the parser does not have enough capacity and memory allocation fails.
\item C\+A\+P\+A\+C\+I\+TY if the parser does not have enough capacity and len $>$ max\+\_\+capacity.
\item other json errors if parsing fails. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 79 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_aeb4dda9e15917e22b4679aa2b9cf97ab}\label{classsimdjson_1_1dom_1_1parser_aeb4dda9e15917e22b4679aa2b9cf97ab}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!load\_many@{load\_many}}
\index{load\_many@{load\_many}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{load\_many()}{load\_many()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{document\+\_\+stream}} $>$ simdjson\+::dom\+::parser\+::load\+\_\+many (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path,  }\item[{size\+\_\+t}]{batch\+\_\+size = {\ttfamily DEFAULT\+\_\+BATCH\+\_\+SIZE} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Load a file containing many J\+S\+ON documents. 

\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{dom\+::parser}} parser; for (const element doc \+: parser.\+load\+\_\+many(path)) \{ cout $<$$<$ std\+::string(doc\mbox{[}\char`\"{}title\char`\"{}\mbox{]}) $<$$<$ endl; \}\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md71}{}\doxyparagraph{Format}\label{classsimdjson_1_1dom_1_1parser_autotoc_md71}
The file must contain a series of one or more J\+S\+ON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)

documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.\+e. documents that are not arrays or objects) M\+U\+ST be separated with whitespace.

The documents must not exceed batch\+\_\+size bytes (by default 1MB) or they will fail to parse. Setting batch\+\_\+size to excessively large or excesively small values may impact negatively the performance.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md72}{}\doxyparagraph{Error Handling}\label{classsimdjson_1_1dom_1_1parser_autotoc_md72}
All errors are returned during iteration\+: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.

As with all other simdjson methods, non-\/exception error handling is readily available through the same interface, requiring you to check the error before using the document\+:

\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{dom\+::parser}} parser; \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{dom\+::document\+\_\+stream}} docs; auto error = parser.\+load\+\_\+many(path).get(docs); if (error) \{ cerr $<$$<$ error $<$$<$ endl; exit(1); \} for (auto doc \+: docs) \{ std\+::string\+\_\+view title; if ((error = doc\mbox{[}\char`\"{}title\char`\"{}\mbox{]}.get(title)) \{ cerr $<$$<$ error $<$$<$ endl; exit(1); \} cout $<$$<$ title $<$$<$ endl; \}\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md73}{}\doxyparagraph{Threads}\label{classsimdjson_1_1dom_1_1parser_autotoc_md73}
When compiled with S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+T\+H\+R\+E\+A\+D\+S\+\_\+\+E\+N\+A\+B\+L\+ED, this method will use a single thread under the hood to do some lookahead.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md74}{}\doxyparagraph{Parser Capacity}\label{classsimdjson_1_1dom_1_1parser_autotoc_md74}
If the parser\textquotesingle{}s current capacity is less than batch\+\_\+size, it will allocate enough capacity to handle it (up to max\+\_\+capacity).


\begin{DoxyParams}{Parameters}
{\em path} & File name pointing at the concatenated J\+S\+ON to parse. \\
\hline
{\em batch\+\_\+size} & The batch size to use. M\+U\+ST be larger than the largest document. The sweet spot is cache-\/related\+: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The stream, or an error. An empty input will yield 0 documents rather than an E\+M\+P\+TY error. Errors\+:
\begin{DoxyItemize}
\item I\+O\+\_\+\+E\+R\+R\+OR if there was an error opening or reading the file.
\item M\+E\+M\+A\+L\+L\+OC if the parser does not have enough capacity and memory allocation fails.
\item C\+A\+P\+A\+C\+I\+TY if the parser does not have enough capacity and batch\+\_\+size $>$ max\+\_\+capacity.
\item other json errors if parsing fails. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 86 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a6b68d9202cd9aa595c2c505e09deb2b2}\label{classsimdjson_1_1dom_1_1parser_a6b68d9202cd9aa595c2c505e09deb2b2}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!max\_capacity@{max\_capacity}}
\index{max\_capacity@{max\_capacity}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{max\_capacity()}{max\_capacity()}}
{\footnotesize\ttfamily really\+\_\+inline size\+\_\+t simdjson\+::dom\+::parser\+::max\+\_\+capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}



The largest document this parser can automatically support. 

The parser may reallocate internal buffers as needed up to this amount.

\begin{DoxyReturn}{Returns}
Maximum capacity, in bytes. 
\end{DoxyReturn}


Definition at line 139 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a6a0b970821b8ecb98a0222a9fa4eb57a}\label{classsimdjson_1_1dom_1_1parser_a6a0b970821b8ecb98a0222a9fa4eb57a}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!max\_depth@{max\_depth}}
\index{max\_depth@{max\_depth}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{max\_depth()}{max\_depth()}}
{\footnotesize\ttfamily really\+\_\+inline size\+\_\+t simdjson\+::dom\+::parser\+::max\+\_\+depth (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}



The maximum level of nested object and arrays supported by this parser. 

\begin{DoxyReturn}{Returns}
Maximum depth, in bytes. 
\end{DoxyReturn}


Definition at line 142 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a778a9b5712f29638cf1fb3670278f4c6}\label{classsimdjson_1_1dom_1_1parser_a778a9b5712f29638cf1fb3670278f4c6}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!operator=@{operator=}}
\index{operator=@{operator=}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily really\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{parser}} \& simdjson\+::dom\+::parser\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{parser}} \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}



Take another parser\textquotesingle{}s buffers and state. 


\begin{DoxyParams}{Parameters}
{\em other} & The parser to take. Its capacity is zeroed. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a16c7d1e28125ef7d5703244483f70984}\label{classsimdjson_1_1dom_1_1parser_a16c7d1e28125ef7d5703244483f70984}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!parse@{parse}}
\index{parse@{parse}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1element}{element}} $>$ simdjson\+::dom\+::parser\+::parse (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t $\ast$}]{buf,  }\item[{size\+\_\+t}]{len,  }\item[{bool}]{realloc\+\_\+if\+\_\+needed = {\ttfamily true} }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Parse a J\+S\+ON document and return a temporary reference to it. 

\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{dom\+::parser}} parser; element doc = parser.\+parse(buf, len);\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md68}{}\doxyparagraph{I\+M\+P\+O\+R\+T\+A\+N\+T\+: Document Lifetime}\label{classsimdjson_1_1dom_1_1parser_autotoc_md68}
The J\+S\+ON document still lives in the parser\+: this is the most efficient way to parse J\+S\+ON documents because it reuses the same buffers, but you {\itshape must} use the document before you destroy the parser or call \mbox{\hyperlink{classsimdjson_1_1dom_1_1parser_a16c7d1e28125ef7d5703244483f70984}{parse()}} again.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md69}{}\doxyparagraph{R\+E\+Q\+U\+I\+R\+E\+D\+: Buffer Padding}\label{classsimdjson_1_1dom_1_1parser_autotoc_md69}
The buffer must have at least S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+P\+A\+D\+D\+I\+NG extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.

If realloc\+\_\+if\+\_\+needed is true, it is assumed that the buffer does {\itshape not} have enough padding, and it is copied into an enlarged temporary buffer before parsing.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md70}{}\doxyparagraph{Parser Capacity}\label{classsimdjson_1_1dom_1_1parser_autotoc_md70}
If the parser\textquotesingle{}s current capacity is less than len, it will allocate enough capacity to handle it (up to max\+\_\+capacity).


\begin{DoxyParams}{Parameters}
{\em buf} & The J\+S\+ON to parse. Must have at least len + S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+P\+A\+D\+D\+I\+NG allocated bytes, unless realloc\+\_\+if\+\_\+needed is true. \\
\hline
{\em len} & The length of the J\+S\+ON. \\
\hline
{\em realloc\+\_\+if\+\_\+needed} & Whether to reallocate and enlarge the J\+S\+ON buffer to add padding. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The document, or an error\+:
\begin{DoxyItemize}
\item M\+E\+M\+A\+L\+L\+OC if realloc\+\_\+if\+\_\+needed is true or the parser does not have enough capacity, and memory allocation fails.
\item C\+A\+P\+A\+C\+I\+TY if the parser does not have enough capacity and len $>$ max\+\_\+capacity.
\item other json errors if parsing fails. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 93 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_a6bf8c584096b98e6fdbb444e35863113}\label{classsimdjson_1_1dom_1_1parser_a6bf8c584096b98e6fdbb444e35863113}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!parse\_many@{parse\_many}}
\index{parse\_many@{parse\_many}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{parse\_many()}{parse\_many()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{document\+\_\+stream}} $>$ simdjson\+::dom\+::parser\+::parse\+\_\+many (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t $\ast$}]{buf,  }\item[{size\+\_\+t}]{len,  }\item[{size\+\_\+t}]{batch\+\_\+size = {\ttfamily DEFAULT\+\_\+BATCH\+\_\+SIZE} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Parse a buffer containing many J\+S\+ON documents. 

\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{dom\+::parser}} parser; for (element doc \+: parser.\+parse\+\_\+many(buf, len)) \{ cout $<$$<$ std\+::string(doc\mbox{[}\char`\"{}title\char`\"{}\mbox{]}) $<$$<$ endl; \}\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md75}{}\doxyparagraph{Format}\label{classsimdjson_1_1dom_1_1parser_autotoc_md75}
The buffer must contain a series of one or more J\+S\+ON documents, concatenated into a single buffer, separated by whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)

documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. documents that consist of a single primitive (i.\+e. documents that are not arrays or objects) M\+U\+ST be separated with whitespace.

The documents must not exceed batch\+\_\+size bytes (by default 1MB) or they will fail to parse. Setting batch\+\_\+size to excessively large or excesively small values may impact negatively the performance.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md76}{}\doxyparagraph{Error Handling}\label{classsimdjson_1_1dom_1_1parser_autotoc_md76}
All errors are returned during iteration\+: if there is a global error such as memory allocation, it will be yielded as the first result. Iteration always stops after the first error.

As with all other simdjson methods, non-\/exception error handling is readily available through the same interface, requiring you to check the error before using the document\+:

\mbox{\hyperlink{classsimdjson_1_1dom_1_1parser}{dom\+::parser}} parser; \mbox{\hyperlink{classsimdjson_1_1dom_1_1document__stream}{dom\+::document\+\_\+stream}} docs; auto error = parser.\+load\+\_\+many(path).get(docs); if (error) \{ cerr $<$$<$ error $<$$<$ endl; exit(1); \} for (auto doc \+: docs) \{ std\+::string\+\_\+view title; if ((error = doc\mbox{[}\char`\"{}title\char`\"{}\mbox{]}.get(title)) \{ cerr $<$$<$ error $<$$<$ endl; exit(1); \} cout $<$$<$ title $<$$<$ endl; \}\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md77}{}\doxyparagraph{R\+E\+Q\+U\+I\+R\+E\+D\+: Buffer Padding}\label{classsimdjson_1_1dom_1_1parser_autotoc_md77}
The buffer must have at least S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+P\+A\+D\+D\+I\+NG extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md78}{}\doxyparagraph{Threads}\label{classsimdjson_1_1dom_1_1parser_autotoc_md78}
When compiled with S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+T\+H\+R\+E\+A\+D\+S\+\_\+\+E\+N\+A\+B\+L\+ED, this method will use a single thread under the hood to do some lookahead.\hypertarget{classsimdjson_1_1dom_1_1parser_autotoc_md79}{}\doxyparagraph{Parser Capacity}\label{classsimdjson_1_1dom_1_1parser_autotoc_md79}
If the parser\textquotesingle{}s current capacity is less than batch\+\_\+size, it will allocate enough capacity to handle it (up to max\+\_\+capacity).


\begin{DoxyParams}{Parameters}
{\em buf} & The concatenated J\+S\+ON to parse. Must have at least len + S\+I\+M\+D\+J\+S\+O\+N\+\_\+\+P\+A\+D\+D\+I\+NG allocated bytes. \\
\hline
{\em len} & The length of the concatenated J\+S\+ON. \\
\hline
{\em batch\+\_\+size} & The batch size to use. M\+U\+ST be larger than the largest document. The sweet spot is cache-\/related\+: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The stream, or an error. An empty input will yield 0 documents rather than an E\+M\+P\+TY error. Errors\+:
\begin{DoxyItemize}
\item M\+E\+M\+A\+L\+L\+OC if the parser does not have enough capacity and memory allocation fails
\item C\+A\+P\+A\+C\+I\+TY if the parser does not have enough capacity and batch\+\_\+size $>$ max\+\_\+capacity.
\item other json errors if parsing fails.
\end{DoxyItemize}
\end{DoxyReturn}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Definition at line 123 of file parser.\+h.

\mbox{\Hypertarget{classsimdjson_1_1dom_1_1parser_acbc6d25fb25b52dcafc32c3855ffeb98}\label{classsimdjson_1_1dom_1_1parser_acbc6d25fb25b52dcafc32c3855ffeb98}} 
\index{simdjson::dom::parser@{simdjson::dom::parser}!set\_max\_capacity@{set\_max\_capacity}}
\index{set\_max\_capacity@{set\_max\_capacity}!simdjson::dom::parser@{simdjson::dom::parser}}
\doxysubsubsection{\texorpdfstring{set\_max\_capacity()}{set\_max\_capacity()}}
{\footnotesize\ttfamily really\+\_\+inline void simdjson\+::dom\+::parser\+::set\+\_\+max\+\_\+capacity (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{max\+\_\+capacity }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Set max\+\_\+capacity. 

This is the largest document this parser can automatically support.

The parser may reallocate internal buffers as needed up to this amount as documents are passed to it.

This call will not allocate or deallocate, even if capacity is currently above max\+\_\+capacity.


\begin{DoxyParams}{Parameters}
{\em max\+\_\+capacity} & The new maximum capacity, in bytes. \\
\hline
\end{DoxyParams}


Definition at line 191 of file parser.\+h.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/simdjson/dom/parser.\+h\end{DoxyCompactItemize}
